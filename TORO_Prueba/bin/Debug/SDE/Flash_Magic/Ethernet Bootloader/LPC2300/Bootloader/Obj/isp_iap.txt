; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--thumb --debug -c --asm --interleave -o.\Obj\isp_iap.o --depend=.\Obj\isp_iap.d --apcs=interwork -O3 -ID:\Keil\ARM\INC -ID:\Keil\ARM\INC\Philips --omf_browse=.\Obj\isp_iap.crf isp\isp_iap.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  is_div PROC
;;;34     
;;;35     int is_div(unsigned value,unsigned div)
000000  1e49              SUBS     r1,r1,#1
;;;36     {
;;;37         if(value & (div -1))
000002  4008              ANDS     r0,r0,r1
000004  d000              BEQ      |L1.8|
;;;38         {
;;;39             return(1);
000006  2001              MOVS     r0,#1
                  |L1.8|
;;;40         }
;;;41         else
;;;42         {
;;;43             return(0);
;;;44         }
;;;45     }/* is_div */
000008  4770              BX       lr
;;;46     
                          ENDP

                  __rt_div0 PROC
;;;47     void __rt_div0(void)
00000a  4770              BX       lr
;;;48     {
;;;49     } /* __rt_div0 */
;;;50     
                          ENDP

                  str_cmp PROC
;;;51     int str_cmp(char * src, char * dst)
00000c  b410              PUSH     {r4}
;;;52     {
;;;53         int i = 0;
00000e  2200              MOVS     r2,#0
;;;54         
;;;55         for(i=0;src[i] == dst[i];i++)
000010  e005              B        |L1.30|
                  |L1.18|
;;;56         {
;;;57             if(src[i] == NUL)
000012  2b00              CMP      r3,#0
000014  d102              BNE      |L1.28|
;;;58             {
;;;59                 return(NUL);
000016  2000              MOVS     r0,#0
                  |L1.24|
;;;60             }
;;;61         }
;;;62         return(src[i]-dst[i]);
;;;63     } /* str_cmp */
000018  bc10              POP      {r4}
00001a  4770              BX       lr
                  |L1.28|
00001c  1c52              ADDS     r2,r2,#1              ;55
                  |L1.30|
00001e  5c83              LDRB     r3,[r0,r2]            ;55
000020  5c8c              LDRB     r4,[r1,r2]            ;55
000022  42a3              CMP      r3,r4                 ;55
000024  d0f5              BEQ      |L1.18|
000026  5c80              LDRB     r0,[r0,r2]            ;62
000028  5c89              LDRB     r1,[r1,r2]            ;62
00002a  1a40              SUBS     r0,r0,r1              ;62
00002c  e7f4              B        |L1.24|
;;;64     
                          ENDP

                  a_to_i PROC
;;;65     int a_to_i(char * inbuf,unsigned * outint)
00002e  b430              PUSH     {r4,r5}
;;;66     {
;;;67         unsigned int value=0,i;
000030  2400              MOVS     r4,#0
;;;68         
;;;69         for(i=0;inbuf[i] != 0;i++)
000032  0022              MOVS     r2,r4
000034  e008              B        |L1.72|
                  |L1.54|
;;;70         {
;;;71             if(inbuf[i] >= '0' && inbuf[i] <= '9')
000036  001d              MOVS     r5,r3
000038  3d30              SUBS     r5,r5,#0x30
00003a  2d09              CMP      r5,#9
00003c  d80b              BHI      |L1.86|
;;;72             {
;;;73                 value = 10 * value +(inbuf[i] - '0');
00003e  250a              MOVS     r5,#0xa
000040  436c              MULS     r4,r5,r4
000042  3c30              SUBS     r4,r4,#0x30
000044  191c              ADDS     r4,r3,r4
000046  1c52              ADDS     r2,r2,#1              ;69
                  |L1.72|
000048  5c83              LDRB     r3,[r0,r2]            ;69
00004a  2b00              CMP      r3,#0                 ;69
00004c  d1f3              BNE      |L1.54|
;;;74             }
;;;75             else
;;;76             {
;;;77                 return(1);
;;;78             }
;;;79         }
;;;80         *outint = value;
;;;81         return(0);
00004e  2000              MOVS     r0,#0
000050  600c              STR      r4,[r1,#0]
                  |L1.82|
;;;82     } /* a_to_i */
000052  bc30              POP      {r4,r5}
000054  4770              BX       lr
                  |L1.86|
000056  2001              MOVS     r0,#1                 ;77
000058  e7fb              B        |L1.82|
;;;83     
                          ENDP

                  i_to_a PROC
;;;84     
;;;85     char * i_to_a(unsigned i_num, char * str, unsigned str_len)
00005a  b570              PUSH     {r4-r6,lr}
;;;86     {
00005c  000d              MOVS     r5,r1
;;;87         char remainder;
;;;88     
;;;89         str[--str_len] = NUL;
00005e  1e52              SUBS     r2,r2,#1
000060  2100              MOVS     r1,#0
000062  0014              MOVS     r4,r2
;;;90     
;;;91         if(i_num == 0)
000064  2800              CMP      r0,#0
000066  54a9              STRB     r1,[r5,r2]            ;89
000068  d10d              BNE      |L1.134|
;;;92         {
;;;93             str[--str_len] = '0';
00006a  2030              MOVS     r0,#0x30
00006c  1e64              SUBS     r4,r4,#1
00006e  5528              STRB     r0,[r5,r4]
;;;94             return(str + str_len);
000070  e00d              B        |L1.142|
                  |L1.114|
;;;95         }
;;;96     
;;;97         while (((str_len>0) && (i_num!=0)))
;;;98         {
;;;99             str_len--;
000072  1e64              SUBS     r4,r4,#1
;;;100            remainder = (char) (i_num % 10);
000074  210a              MOVS     r1,#0xa
000076  f7fffffe          BL       __aeabi_uidivmod
;;;101            if ( remainder <= 9 )
00007a  2909              CMP      r1,#9
00007c  d801              BHI      |L1.130|
;;;102            {
;;;103                str[str_len] = remainder + '0';
00007e  3130              ADDS     r1,r1,#0x30
000080  e000              B        |L1.132|
                  |L1.130|
;;;104            }
;;;105            else  
;;;106            {
;;;107                str[str_len] = remainder - 10 + 'A';
000082  3137              ADDS     r1,r1,#0x37
                  |L1.132|
000084  5529              STRB     r1,[r5,r4]            ;103
                  |L1.134|
000086  2c00              CMP      r4,#0                 ;97
000088  d001              BEQ      |L1.142|
00008a  2800              CMP      r0,#0                 ;97
00008c  d1f1              BNE      |L1.114|
                  |L1.142|
;;;108            }
;;;109            i_num = i_num/10;
;;;110        }
;;;111        return (str + str_len);
00008e  1928              ADDS     r0,r5,r4
                  |L1.144|
;;;112    } /* i_to_a */
000090  bc70              POP      {r4-r6}
000092  bc08              POP      {r3}
000094  4718              BX       r3
;;;113    
                          ENDP

                  run_isp PROC
;;;114    const char sync_str[] = "Synchronized";
;;;115    void run_isp(void)
000096  b508              PUSH     {r3,lr}
;;;116    {
;;;117        int count;
;;;118    
;;;119        /* wait for host to initiate communication */
;;;120    	getline(cmd_buf,CMD_SIZE,&count);
000098  2146              MOVS     r1,#0x46
00009a  466a              MOV      r2,sp
00009c  48ff              LDR      r0,|L1.1180|
00009e  f7fffffe          BL       getline
;;;121    
;;;122    	/* send "Synchronized" string response */
;;;123    	sendline_crlf((char *)sync_str);
0000a2  48ff              LDR      r0,|L1.1184|
0000a4  f7fffffe          BL       sendline_crlf
;;;124    
;;;125        /* wait for host to respond */
;;;126    	getline(cmd_buf,CMD_SIZE,&count);
0000a8  48fc              LDR      r0,|L1.1180|
0000aa  2146              MOVS     r1,#0x46
0000ac  466a              MOV      r2,sp
0000ae  f7fffffe          BL       getline
;;;127    
;;;128    	/* Compare HOST response with the original string */
;;;129    	if(str_cmp(cmd_buf,(char *)sync_str) == 0)
0000b2  49fb              LDR      r1,|L1.1184|
0000b4  48f9              LDR      r0,|L1.1180|
0000b6  f7fffffe          BL       str_cmp
;;;130    	{
;;;131    		/* Autobaud is successful. Get out of while loop. */
;;;132    	}
;;;133    	else
;;;134    	{
;;;135    	}
;;;136    }
0000ba  b001              ADD      sp,sp,#4
0000bc  bc08              POP      {r3}
0000be  4718              BX       r3
;;;137    
                          ENDP

                  param_check PROC
;;;138    unsigned param_check(char * param_str,unsigned * param_ptr,int param_type,int count)
0000c0  b5f0              PUSH     {r4-r7,lr}
;;;139    {
0000c2  000f              MOVS     r7,r1
0000c4  0015              MOVS     r5,r2
0000c6  001e              MOVS     r6,r3
;;;140        int rc,return_code,in_flash,in_ram;
;;;141        return_code = 0;
0000c8  2400              MOVS     r4,#0
;;;142        /* check if conversion from str to integer is required */
;;;143        if(param_str != NUL)
0000ca  2800              CMP      r0,#0
0000cc  d008              BEQ      |L1.224|
;;;144        {
;;;145            rc = a_to_i(param_str,param_ptr);
0000ce  0039              MOVS     r1,r7
0000d0  f7fffffe          BL       a_to_i
;;;146            if(rc != 0)
0000d4  2800              CMP      r0,#0
0000d6  d003              BEQ      |L1.224|
;;;147            {
;;;148                return(PARAM_ERROR);
0000d8  200c              MOVS     r0,#0xc
                  |L1.218|
;;;149            }
;;;150        }
;;;151    
;;;152        if(param_type == NO_PARAM_CHECK)
;;;153        {
;;;154            /* further testing is not required. Verification is done in  
;;;155               related commands */
;;;156            return(0);
;;;157        }
;;;158        
;;;159        rc = is_div(*param_ptr,BY_4);
;;;160        if( rc != 0)
;;;161        {   
;;;162            if(param_type == COUNT)
;;;163            {
;;;164                return_code = COUNT_ERROR;
;;;165            }
;;;166            else
;;;167            {
;;;168                return_code = ADDR_ERROR;
;;;169                /* Now distinguish between SRC & DST if required */
;;;170                if(param_type == RAM_ADDRESS)
;;;171                {
;;;172                    return_code = SRC_ADDR_ERROR;
;;;173                }
;;;174                if(param_type == FLASH_ADDRESS)
;;;175                {
;;;176                    return_code = DST_ADDR_ERROR;
;;;177                }
;;;178            } /* Address error */
;;;179        } /* is_div by 4 error */
;;;180    
;;;181        /* Check for address mapping if required. Each type of address requires a 
;;;182        different type of test. Do this testing only if previous test is ok */
;;;183        if(return_code == 0)
;;;184        {
;;;185            if( ((*param_ptr >= RAM_START) && ((*param_ptr+count) <= (RAM_END+1))) )
;;;186            {
;;;187                in_ram = TRUE;
;;;188            }
;;;189            else
;;;190            {
;;;191                in_ram = FALSE;
;;;192            }
;;;193            if( ((*param_ptr >= USER_START_SECTOR_ADDRESS) && ((*param_ptr+count) <= (USER_END_SECTOR_ADDRESS+1))) )
;;;194            {
;;;195                in_flash = TRUE;
;;;196            }
;;;197            else
;;;198            {
;;;199                in_flash = FALSE;
;;;200            }
;;;201            if(param_type == RAM_OR_FLASH_ADDRESS)
;;;202            {
;;;203                if( !(in_ram || in_flash) )
;;;204                {
;;;205                    return_code = ADDR_NOT_MAPPED;
;;;206                }
;;;207            }
;;;208            if(param_type == RAM_ADDRESS)
;;;209            {
;;;210                if( !(in_ram) )
;;;211                {
;;;212                    return_code = SRC_ADDR_NOT_MAPPED;
;;;213                }
;;;214            }
;;;215        }
;;;216        return(return_code);
;;;217    }/* param_check */
0000da  bcf0              POP      {r4-r7}
0000dc  bc08              POP      {r3}
0000de  4718              BX       r3
                  |L1.224|
0000e0  2d69              CMP      r5,#0x69              ;152
0000e2  d101              BNE      |L1.232|
0000e4  2000              MOVS     r0,#0                 ;156
0000e6  e7f8              B        |L1.218|
                  |L1.232|
0000e8  6838              LDR      r0,[r7,#0]            ;159
0000ea  2104              MOVS     r1,#4                 ;159
0000ec  f7fffffe          BL       is_div
0000f0  2800              CMP      r0,#0                 ;160
0000f2  d00e              BEQ      |L1.274|
0000f4  2d64              CMP      r5,#0x64              ;162
0000f6  d101              BNE      |L1.252|
0000f8  2406              MOVS     r4,#6                 ;164
0000fa  e02d              B        |L1.344|
                  |L1.252|
0000fc  240d              MOVS     r4,#0xd               ;168
0000fe  2d67              CMP      r5,#0x67              ;170
000100  d101              BNE      |L1.262|
000102  2402              MOVS     r4,#2                 ;172
000104  e028              B        |L1.344|
                  |L1.262|
000106  2d68              CMP      r5,#0x68              ;174
000108  d101              BNE      |L1.270|
00010a  2403              MOVS     r4,#3                 ;176
00010c  e024              B        |L1.344|
                  |L1.270|
00010e  2c00              CMP      r4,#0                 ;183
000110  d122              BNE      |L1.344|
                  |L1.274|
000112  6839              LDR      r1,[r7,#0]            ;185
000114  2001              MOVS     r0,#1                 ;185
000116  0780              LSLS     r0,r0,#30             ;185
000118  4281              CMP      r1,r0                 ;185
00011a  d305              BCC      |L1.296|
00011c  4ae1              LDR      r2,|L1.1188|
00011e  1988              ADDS     r0,r1,r6              ;185
000120  4290              CMP      r0,r2                 ;185
000122  d801              BHI      |L1.296|
000124  2001              MOVS     r0,#1                 ;187
000126  e000              B        |L1.298|
                  |L1.296|
000128  2000              MOVS     r0,#0                 ;191
                  |L1.298|
00012a  2201              MOVS     r2,#1                 ;193
00012c  0352              LSLS     r2,r2,#13             ;193
00012e  4291              CMP      r1,r2                 ;193
000130  d306              BCC      |L1.320|
000132  223f              MOVS     r2,#0x3f              ;193
000134  1989              ADDS     r1,r1,r6              ;193
000136  0352              LSLS     r2,r2,#13             ;193
000138  4291              CMP      r1,r2                 ;193
00013a  d801              BHI      |L1.320|
00013c  2101              MOVS     r1,#1                 ;195
00013e  e000              B        |L1.322|
                  |L1.320|
000140  2100              MOVS     r1,#0                 ;199
                  |L1.322|
000142  2d66              CMP      r5,#0x66              ;201
000144  d103              BNE      |L1.334|
000146  4308              ORRS     r0,r0,r1              ;203
000148  d106              BNE      |L1.344|
00014a  240e              MOVS     r4,#0xe               ;205
00014c  e004              B        |L1.344|
                  |L1.334|
00014e  2d67              CMP      r5,#0x67              ;208
000150  d102              BNE      |L1.344|
000152  2800              CMP      r0,#0                 ;210
000154  d100              BNE      |L1.344|
000156  2404              MOVS     r4,#4                 ;212
                  |L1.344|
000158  0020              MOVS     r0,r4                 ;216
00015a  e7be              B        |L1.218|
;;;218    
                          ENDP

                  iap_entry PROC
;;;219    void iap_entry(unsigned param_tab[],unsigned result_tab[])
00015c  4ad2              LDR      r2,|L1.1192|
;;;220    {
;;;221        void (*iap)(unsigned [],unsigned []);
;;;222    
;;;223        iap = (void (*)(unsigned [],unsigned []))IAP_ADDRESS;
;;;224        iap(param_tab,result_tab);
00015e  4710              BX       r2
;;;225    }
;;;226    
                          ENDP

                  decode PROC
;;;227    char decode(char c)
000160  2860              CMP      r0,#0x60
;;;228    {
;;;229        if(c == 0x60)
000162  d101              BNE      |L1.360|
;;;230        {
;;;231            return(0x00);
000164  2000              MOVS     r0,#0
;;;232        }
;;;233        else
;;;234        {
;;;235            return(c - SP);
;;;236        }
;;;237    }
000166  4770              BX       lr
                  |L1.360|
000168  3820              SUBS     r0,r0,#0x20           ;235
00016a  0600              LSLS     r0,r0,#24             ;235
00016c  0e00              LSRS     r0,r0,#24             ;235
00016e  4770              BX       lr
;;;238    
                          ENDP

                  uudecode PROC
;;;239    unsigned uudecode(char * inbuf, char * outbuf, int * count)
000170  b5f0              PUSH     {r4-r7,lr}
;;;240    {
000172  0003              MOVS     r3,r0
;;;241        unsigned sum;
;;;242        int in_byte_count,out_byte_count;
;;;243        
;;;244        sum=0;
000174  2600              MOVS     r6,#0
;;;245        out_byte_count=0;
;;;246        in_byte_count = decode(*inbuf);
000176  7800              LDRB     r0,[r0,#0]
000178  0035              MOVS     r5,r6                 ;245
00017a  f7fffffe          BL       decode
00017e  0004              MOVS     r4,r0
;;;247        /* Do not decode if byte count is > 45 */
;;;248        if( (in_byte_count > 0) && (in_byte_count <= UU_LINE) )
000180  1e40              SUBS     r0,r0,#1
000182  282c              CMP      r0,#0x2c
000184  d84b              BHI      |L1.542|
;;;249        {
;;;250            for (++inbuf; in_byte_count > 0; inbuf += 4, in_byte_count -= 3)
000186  1c5b              ADDS     r3,r3,#1
000188  e047              B        |L1.538|
                  |L1.394|
;;;251            {
;;;252                /* !!! Test for valid printable character is not done !!! */
;;;253                if(in_byte_count >= 3)
00018a  2c03              CMP      r4,#3
00018c  db25              BLT      |L1.474|
;;;254                {
;;;255                    outbuf[0] = (decode(inbuf[0]) << 2) | (decode(inbuf[1]) >> 4);
00018e  7818              LDRB     r0,[r3,#0]
000190  f7fffffe          BL       decode
000194  0087              LSLS     r7,r0,#2
000196  7858              LDRB     r0,[r3,#1]
000198  f7fffffe          BL       decode
00019c  0900              LSRS     r0,r0,#4
00019e  4307              ORRS     r7,r7,r0
0001a0  700f              STRB     r7,[r1,#0]
;;;256                    outbuf[1] = (decode(inbuf[1]) << 4) | (decode(inbuf[2]) >> 2);
0001a2  7858              LDRB     r0,[r3,#1]
0001a4  f7fffffe          BL       decode
0001a8  0107              LSLS     r7,r0,#4
0001aa  7898              LDRB     r0,[r3,#2]
0001ac  f7fffffe          BL       decode
0001b0  0880              LSRS     r0,r0,#2
0001b2  4307              ORRS     r7,r7,r0
0001b4  704f              STRB     r7,[r1,#1]
;;;257                    outbuf[2] = (decode(inbuf[2]) << 6) | (decode(inbuf[3]));
0001b6  7898              LDRB     r0,[r3,#2]
0001b8  f7fffffe          BL       decode
0001bc  0187              LSLS     r7,r0,#6
0001be  78d8              LDRB     r0,[r3,#3]
0001c0  f7fffffe          BL       decode
0001c4  4307              ORRS     r7,r7,r0
0001c6  708f              STRB     r7,[r1,#2]
;;;258                    out_byte_count += 3;
;;;259                    sum = sum + outbuf[0] + outbuf[1] + outbuf[2];
0001c8  7808              LDRB     r0,[r1,#0]
0001ca  784f              LDRB     r7,[r1,#1]
0001cc  1ced              ADDS     r5,r5,#3              ;258
0001ce  19c0              ADDS     r0,r0,r7
0001d0  788f              LDRB     r7,[r1,#2]
0001d2  19be              ADDS     r6,r7,r6
0001d4  1986              ADDS     r6,r0,r6
;;;260                    outbuf+=3;
0001d6  1cc9              ADDS     r1,r1,#3
0001d8  e01d              B        |L1.534|
                  |L1.474|
;;;261                }
;;;262                else
;;;263                {
;;;264                     if(in_byte_count >= 1)
0001da  2c01              CMP      r4,#1
0001dc  db0c              BLT      |L1.504|
;;;265                    {
;;;266                        outbuf[0] = (decode(inbuf[0]) << 2) | (decode(inbuf[1]) >> 4);
0001de  7818              LDRB     r0,[r3,#0]
0001e0  f7fffffe          BL       decode
0001e4  0087              LSLS     r7,r0,#2
0001e6  7858              LDRB     r0,[r3,#1]
0001e8  f7fffffe          BL       decode
0001ec  0900              LSRS     r0,r0,#4
0001ee  4307              ORRS     r7,r7,r0
0001f0  700f              STRB     r7,[r1,#0]
;;;267                        out_byte_count++;
;;;268                        sum = sum + outbuf[0];
0001f2  7808              LDRB     r0,[r1,#0]
0001f4  1c6d              ADDS     r5,r5,#1              ;267
0001f6  1986              ADDS     r6,r0,r6
                  |L1.504|
;;;269                      /* No need to increment the outbuf as this is the last for loop iteration */
;;;270                    }
;;;271                    if(in_byte_count >= 2)
0001f8  2c02              CMP      r4,#2
0001fa  db0c              BLT      |L1.534|
;;;272                    {
;;;273                        outbuf[1] = (decode(inbuf[1]) << 4) | (decode(inbuf[2]) >> 2);
0001fc  7858              LDRB     r0,[r3,#1]
0001fe  f7fffffe          BL       decode
000202  0107              LSLS     r7,r0,#4
000204  7898              LDRB     r0,[r3,#2]
000206  f7fffffe          BL       decode
00020a  0880              LSRS     r0,r0,#2
00020c  4307              ORRS     r7,r7,r0
00020e  704f              STRB     r7,[r1,#1]
;;;274                        out_byte_count++;
;;;275                        sum = sum + outbuf[1];
000210  7848              LDRB     r0,[r1,#1]
000212  1c6d              ADDS     r5,r5,#1              ;274
000214  1986              ADDS     r6,r0,r6
                  |L1.534|
000216  1d1b              ADDS     r3,r3,#4              ;250
000218  1ee4              SUBS     r4,r4,#3              ;250
                  |L1.538|
00021a  2c00              CMP      r4,#0                 ;250
00021c  dcb5              BGT      |L1.394|
                  |L1.542|
;;;276                      /* No need to increment the outbuf as this is the last for loop iteration */
;;;277                    }
;;;278                }
;;;279            } /* for loop */
;;;280        }
;;;281        *count = out_byte_count;
;;;282        return(sum);
00021e  0030              MOVS     r0,r6
000220  6015              STR      r5,[r2,#0]
;;;283    } /* uudecode */
000222  e75a              B        |L1.218|
;;;284    
                          ENDP

                  encode PROC
;;;285    char encode(char c)
000224  2800              CMP      r0,#0
;;;286    {
;;;287        if( c == 0x00)
000226  d101              BNE      |L1.556|
;;;288        {
;;;289            return(0x60);
000228  2060              MOVS     r0,#0x60
;;;290        }
;;;291        else
;;;292        {
;;;293            return(c+SP);
;;;294        }
;;;295    }
00022a  4770              BX       lr
                  |L1.556|
00022c  3020              ADDS     r0,r0,#0x20           ;293
00022e  0600              LSLS     r0,r0,#24             ;293
000230  0e00              LSRS     r0,r0,#24             ;293
000232  4770              BX       lr
;;;296    
                          ENDP

                  uuencode PROC
;;;297    unsigned uuencode(char * inbuf, char * outbuf, int count)
000234  b5f0              PUSH     {r4-r7,lr}
;;;298    {
000236  0003              MOVS     r3,r0
;;;299        unsigned sum;
;;;300        char byte1,byte2;
;;;301        sum = 0;
;;;302        *outbuf = encode(count);
000238  0610              LSLS     r0,r2,#24
00023a  2400              MOVS     r4,#0                 ;301
00023c  0e00              LSRS     r0,r0,#24
00023e  f7fffffe          BL       encode
000242  7008              STRB     r0,[r1,#0]
;;;303        outbuf++;
000244  1c49              ADDS     r1,r1,#1
;;;304        while(count>0)
000246  e02d              B        |L1.676|
                  |L1.584|
;;;305        {
;;;306            if(count >= 3)
000248  2a03              CMP      r2,#3
00024a  db04              BLT      |L1.598|
;;;307            {
;;;308                byte1 = inbuf[1];
;;;309                byte2 = inbuf[2];
00024c  789e              LDRB     r6,[r3,#2]
00024e  785d              LDRB     r5,[r3,#1]            ;308
;;;310                sum = sum + inbuf[0] + inbuf[1] + inbuf[2];
000250  7818              LDRB     r0,[r3,#0]
000252  1934              ADDS     r4,r6,r4
000254  e004              B        |L1.608|
                  |L1.598|
;;;311            }
;;;312            else
;;;313            {
;;;314                if(count == 2)
000256  2a02              CMP      r2,#2
000258  d105              BNE      |L1.614|
;;;315                {
;;;316                    byte1 = inbuf[1];
00025a  785d              LDRB     r5,[r3,#1]
;;;317                    byte2 = inbuf[1];
;;;318                    sum = sum + inbuf[0] + inbuf[1];
00025c  7818              LDRB     r0,[r3,#0]
00025e  002e              MOVS     r6,r5                 ;317
                  |L1.608|
000260  1940              ADDS     r0,r0,r5
000262  1904              ADDS     r4,r0,r4
000264  e002              B        |L1.620|
                  |L1.614|
;;;319                }
;;;320                else
;;;321                {
;;;322                    byte1 = inbuf[0];
000266  781d              LDRB     r5,[r3,#0]
;;;323                    byte2 = inbuf[0];
000268  002e              MOVS     r6,r5
;;;324                    sum = sum + inbuf[0];
00026a  192c              ADDS     r4,r5,r4
                  |L1.620|
;;;325                }
;;;326            }
;;;327            outbuf[0] = encode(((inbuf[0] >> 2) & 0x3F));
00026c  7818              LDRB     r0,[r3,#0]
00026e  0880              LSRS     r0,r0,#2
000270  f7fffffe          BL       encode
000274  7008              STRB     r0,[r1,#0]
;;;328            outbuf[1] = encode(((inbuf[0] & 0x03) << 4) + ((byte1 & 0xF0) >> 4));
000276  7818              LDRB     r0,[r3,#0]
000278  092f              LSRS     r7,r5,#4
00027a  0780              LSLS     r0,r0,#30
00027c  0e80              LSRS     r0,r0,#26
00027e  19c0              ADDS     r0,r0,r7
000280  f7fffffe          BL       encode
000284  7048              STRB     r0,[r1,#1]
;;;329            outbuf[2] = encode(((byte1 & 0x0F) << 2) + ((byte2 & 0xC0) >> 6));
000286  0728              LSLS     r0,r5,#28
000288  0e80              LSRS     r0,r0,#26
00028a  09b5              LSRS     r5,r6,#6
00028c  1940              ADDS     r0,r0,r5
00028e  f7fffffe          BL       encode
000292  7088              STRB     r0,[r1,#2]
;;;330            outbuf[3] = encode((byte2 & 0x3F));
000294  06b0              LSLS     r0,r6,#26
000296  0e80              LSRS     r0,r0,#26
000298  f7fffffe          BL       encode
00029c  70c8              STRB     r0,[r1,#3]
;;;331            outbuf+=4;
00029e  1d09              ADDS     r1,r1,#4
;;;332            inbuf+=3;
0002a0  1cdb              ADDS     r3,r3,#3
;;;333            count-=3;
0002a2  1ed2              SUBS     r2,r2,#3
                  |L1.676|
0002a4  2a00              CMP      r2,#0                 ;304
0002a6  dccf              BGT      |L1.584|
;;;334        } /* while loop */
;;;335        outbuf[0] = NUL;
0002a8  2000              MOVS     r0,#0
0002aa  7008              STRB     r0,[r1,#0]
;;;336        return(sum);
0002ac  0020              MOVS     r0,r4
;;;337    } /* uuencode */
0002ae  e714              B        |L1.218|
;;;338    
                          ENDP

                  write_to_ram PROC
;;;342    
;;;343    void write_to_ram(void)
0002b0  b5f0              PUSH     {r4-r7,lr}
;;;344    {
;;;345        unsigned dst,checksum,recvd_checksum;
;;;346        unsigned line_ctr,last_dst;
;;;347        int count,decode_count,last_cnt,char_cnt;
;;;348        unsigned rc;
;;;349        
;;;350        /* Check count validity first as mapping check requires count */
;;;351        rc = param_check(param_buf[ISP_PARAM_2],(unsigned *)&count,COUNT,count);
0002b2  4d7a              LDR      r5,|L1.1180|
0002b4  b085              SUB      sp,sp,#0x14           ;344
0002b6  3594              ADDS     r5,r5,#0x94
0002b8  68a8              LDR      r0,[r5,#8]  ; param_buf
0002ba  9b02              LDR      r3,[sp,#8]
0002bc  2264              MOVS     r2,#0x64
0002be  a902              ADD      r1,sp,#8
0002c0  f7fffffe          BL       param_check
0002c4  0004              MOVS     r4,r0
;;;352        if(rc == 0)
0002c6  d10d              BNE      |L1.740|
;;;353        {
;;;354            rc = param_check(param_buf[ISP_PARAM_1],&dst,RAM_ADDRESS,count);
0002c8  6868              LDR      r0,[r5,#4]  ; param_buf
0002ca  9b02              LDR      r3,[sp,#8]
0002cc  2267              MOVS     r2,#0x67
0002ce  a904              ADD      r1,sp,#0x10
0002d0  f7fffffe          BL       param_check
0002d4  0004              MOVS     r4,r0
;;;355            if (rc == SRC_ADDR_NOT_MAPPED)
0002d6  2804              CMP      r0,#4
0002d8  d101              BNE      |L1.734|
;;;356            {
;;;357                rc = ADDR_NOT_MAPPED;
0002da  240e              MOVS     r4,#0xe
0002dc  e002              B        |L1.740|
                  |L1.734|
;;;358            }
;;;359            if (rc == SRC_ADDR_ERROR)
0002de  2c02              CMP      r4,#2
0002e0  d100              BNE      |L1.740|
;;;360            {
;;;361                rc = ADDR_ERROR;
0002e2  240d              MOVS     r4,#0xd
                  |L1.740|
;;;362            }
;;;363        }
;;;364        /* Do not allow write to ISP RAM variable area */
;;;365        if( (crp_after_reset == CRP1) )
0002e4  4871              LDR      r0,|L1.1196|
0002e6  4972              LDR      r1,|L1.1200|
0002e8  6840              LDR      r0,[r0,#4]  ; crp_after_reset
0002ea  4288              CMP      r0,r1
0002ec  d105              BNE      |L1.762|
;;;366        {
;;;367             if( ( dst < (RAM_START) ) )
0002ee  9804              LDR      r0,[sp,#0x10]
0002f0  2101              MOVS     r1,#1
0002f2  0789              LSLS     r1,r1,#30
0002f4  4288              CMP      r0,r1
0002f6  d200              BCS      |L1.762|
;;;368             {
;;;369                 rc = CODE_READ_PROTECTION_ENABLED;
0002f8  2413              MOVS     r4,#0x13
                  |L1.762|
;;;370             }
;;;371         }
;;;372     
;;;373        /* Print command result on serial channel */
;;;374        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_0],PARAM_SIZE));
0002fa  6829              LDR      r1,[r5,#0]  ; param_buf
0002fc  220f              MOVS     r2,#0xf
0002fe  0020              MOVS     r0,r4
000300  f7fffffe          BL       i_to_a
000304  f7fffffe          BL       sendline_crlf
;;;375    
;;;376        /* execute command only if parameters are ok */
;;;377        if(rc != CMD_SUCCESS)
000308  2c00              CMP      r4,#0
00030a  d143              BNE      |L1.916|
;;;378        {
;;;379            return;
;;;380        }
;;;381        
;;;382        /* Initialize checksum related variables */
;;;383        checksum = 0;
;;;384        line_ctr = 0;
;;;385        last_dst = dst;
;;;386        last_cnt = count;
;;;387        while(count>0)
00030c  9f02              LDR      r7,[sp,#8]
00030e  9e04              LDR      r6,[sp,#0x10]
000310  0025              MOVS     r5,r4                 ;384
000312  e03c              B        |L1.910|
                  |L1.788|
;;;388        {
;;;389            if(getline(cmd_buf,CMD_SIZE,&char_cnt) != CMD_SUCCESS)
000314  4861              LDR      r0,|L1.1180|
000316  2146              MOVS     r1,#0x46
000318  466a              MOV      r2,sp
00031a  f7fffffe          BL       getline
00031e  2800              CMP      r0,#0
000320  d138              BNE      |L1.916|
;;;390            {
;;;391                /* Abort command */
;;;392                break;
;;;393            }
;;;394            /* Keep track of number of lines decoded. Need to verify checksum
;;;395               once the LINE_CHECKSUM lines are receieved */
;;;396            if(char_cnt != 0) /* Ignore empty lines */
000322  9800              LDR      r0,[sp,#0]
000324  2800              CMP      r0,#0
000326  d00d              BEQ      |L1.836|
;;;397            {
;;;398                line_ctr++;
;;;399                checksum = checksum + uudecode(cmd_buf,(char *)dst,&decode_count);
000328  485c              LDR      r0,|L1.1180|
00032a  9904              LDR      r1,[sp,#0x10]
00032c  1c6d              ADDS     r5,r5,#1              ;398
00032e  aa01              ADD      r2,sp,#4
000330  f7fffffe          BL       uudecode
000334  1904              ADDS     r4,r0,r4
;;;400                dst = dst + decode_count;
000336  9904              LDR      r1,[sp,#0x10]
000338  9801              LDR      r0,[sp,#4]
00033a  1809              ADDS     r1,r1,r0
;;;401                count = count - decode_count;
00033c  9104              STR      r1,[sp,#0x10]
00033e  9902              LDR      r1,[sp,#8]
000340  1a08              SUBS     r0,r1,r0
000342  9002              STR      r0,[sp,#8]
                  |L1.836|
;;;402            }
;;;403            /* Need checksum handshake ? */
;;;404            if( ((line_ctr == LINE_CHECKSUM) || (count == 0)) )
000344  2d14              CMP      r5,#0x14
000346  d002              BEQ      |L1.846|
000348  9802              LDR      r0,[sp,#8]
00034a  2800              CMP      r0,#0
00034c  d11f              BNE      |L1.910|
                  |L1.846|
;;;405            {
;;;406                char_cnt = 0;
00034e  2000              MOVS     r0,#0
000350  9000              STR      r0,[sp,#0]
                  |L1.850|
;;;407                /* Get checksum string (ASCII decimal) from host */
;;;408                while(char_cnt == 0)
;;;409                {
;;;410                    rc = getline(cmd_buf,CMD_SIZE,&char_cnt);
000352  4852              LDR      r0,|L1.1180|
000354  2146              MOVS     r1,#0x46
000356  466a              MOV      r2,sp
000358  f7fffffe          BL       getline
00035c  9900              LDR      r1,[sp,#0]            ;408
00035e  2900              CMP      r1,#0                 ;408
000360  d0f7              BEQ      |L1.850|
;;;411                }
;;;412                if( rc != CMD_SUCCESS)
000362  2800              CMP      r0,#0
000364  d116              BNE      |L1.916|
;;;413                {
;;;414                    break;
;;;415                }
;;;416                /* No error check while conversion to integer. If there is an error
;;;417                it will be trapped by wrong checksum */
;;;418                a_to_i(cmd_buf,&recvd_checksum);
000366  484d              LDR      r0,|L1.1180|
000368  a903              ADD      r1,sp,#0xc
00036a  f7fffffe          BL       a_to_i
;;;419                if( checksum == recvd_checksum)
00036e  9803              LDR      r0,[sp,#0xc]
000370  4284              CMP      r4,r0
000372  d104              BNE      |L1.894|
;;;420                {
;;;421                    last_cnt = count;
;;;422                    last_dst = dst;
;;;423                    sendline_crlf((char *)ok);
000374  484a              LDR      r0,|L1.1184|
000376  9f02              LDR      r7,[sp,#8]
000378  9e04              LDR      r6,[sp,#0x10]
00037a  380a              SUBS     r0,r0,#0xa
00037c  e003              B        |L1.902|
                  |L1.894|
;;;424                }
;;;425                else
;;;426                {
;;;427                    count = last_cnt;
;;;428                    dst = last_dst;
;;;429                    sendline_crlf((char *)resend);
00037e  4848              LDR      r0,|L1.1184|
000380  9702              STR      r7,[sp,#8]
000382  1fc0              SUBS     r0,r0,#7
000384  9604              STR      r6,[sp,#0x10]
                  |L1.902|
000386  f7fffffe          BL       sendline_crlf
;;;430                }
;;;431                /* line counter and checksum has to be reset anyway */
;;;432                line_ctr = 0;
00038a  2500              MOVS     r5,#0
;;;433                checksum = 0;
00038c  002c              MOVS     r4,r5
                  |L1.910|
00038e  9802              LDR      r0,[sp,#8]            ;387
000390  2800              CMP      r0,#0                 ;387
000392  dcbf              BGT      |L1.788|
                  |L1.916|
;;;434            }
;;;435        }/* While loop */
;;;436    } /* write_to_ram */
000394  b005              ADD      sp,sp,#0x14
000396  e6a0              B        |L1.218|
;;;437    
                          ENDP

                  read PROC
;;;438    void read(void)
000398  b5f0              PUSH     {r4-r7,lr}
;;;439    {
;;;440        unsigned src,checksum,last_src,line_ctr;
;;;441        int count,encode_count,last_cnt;
;;;442        unsigned rc;
;;;443    	int char_cnt;
;;;444    
;;;445        /* Check count validity first as address mapping check requires count */
;;;446        rc = param_check(param_buf[ISP_PARAM_2],(unsigned *)&count,COUNT,NUL);
00039a  4d40              LDR      r5,|L1.1180|
00039c  b085              SUB      sp,sp,#0x14           ;439
00039e  3594              ADDS     r5,r5,#0x94
0003a0  68a8              LDR      r0,[r5,#8]  ; param_buf
0003a2  2264              MOVS     r2,#0x64
0003a4  2300              MOVS     r3,#0
0003a6  a902              ADD      r1,sp,#8
0003a8  f7fffffe          BL       param_check
0003ac  0004              MOVS     r4,r0
;;;447        if(rc == 0)
0003ae  d106              BNE      |L1.958|
;;;448        {
;;;449            rc = param_check(param_buf[ISP_PARAM_1],&src,RAM_OR_FLASH_ADDRESS,count);
0003b0  6868              LDR      r0,[r5,#4]  ; param_buf
0003b2  9b02              LDR      r3,[sp,#8]
0003b4  2266              MOVS     r2,#0x66
0003b6  a903              ADD      r1,sp,#0xc
0003b8  f7fffffe          BL       param_check
0003bc  0004              MOVS     r4,r0
                  |L1.958|
;;;450        }
;;;451        /* Print command result on serial channel */
;;;452        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_0],PARAM_SIZE));
0003be  6829              LDR      r1,[r5,#0]  ; param_buf
0003c0  220f              MOVS     r2,#0xf
0003c2  0020              MOVS     r0,r4
0003c4  f7fffffe          BL       i_to_a
0003c8  f7fffffe          BL       sendline_crlf
;;;453        /* execute command only if parameters are ok */
;;;454        if(rc != CMD_SUCCESS)
0003cc  2c00              CMP      r4,#0
0003ce  d1e1              BNE      |L1.916|
;;;455        {
;;;456            return;
;;;457        }
;;;458        
;;;459        /* Initialize checksum related variables */
;;;460        checksum = 0;
;;;461        line_ctr = 0;
;;;462        last_src = src;
;;;463        last_cnt = count;
0003d0  a802              ADD      r0,sp,#8
0003d2  c881              LDM      r0,{r0,r7}
0003d4  2600              MOVS     r6,#0                 ;460
0003d6  0034              MOVS     r4,r6                 ;461
;;;464    
;;;465        while(count > 0)
0003d8  9001              STR      r0,[sp,#4]
0003da  e036              B        |L1.1098|
                  |L1.988|
;;;466        {
;;;467            if(count > UU_LINE)
0003dc  2d2d              CMP      r5,#0x2d
0003de  dd00              BLE      |L1.994|
;;;468            {
;;;469                encode_count = UU_LINE;
0003e0  252d              MOVS     r5,#0x2d
                  |L1.994|
;;;470            }
;;;471            else
;;;472            {
;;;473                encode_count = count;
;;;474            }
;;;475            checksum = checksum + uuencode((char *)src,cmd_buf,encode_count);
0003e2  492e              LDR      r1,|L1.1180|
0003e4  9803              LDR      r0,[sp,#0xc]
0003e6  002a              MOVS     r2,r5
0003e8  f7fffffe          BL       uuencode
0003ec  1986              ADDS     r6,r0,r6
;;;476            if(sendline_crlf(cmd_buf) != 1)
0003ee  482b              LDR      r0,|L1.1180|
0003f0  f7fffffe          BL       sendline_crlf
0003f4  2801              CMP      r0,#1
0003f6  d1cd              BNE      |L1.916|
;;;477            {
;;;478                /* Abort command */
;;;479                break;
;;;480            }
;;;481            /* Keep track of number of lines encoded. Need to send checksum
;;;482               once the LINE_CHECKSUM lines are transmitted */
;;;483            line_ctr++;        
;;;484            src = src + encode_count;
0003f8  9803              LDR      r0,[sp,#0xc]
0003fa  1c64              ADDS     r4,r4,#1              ;483
0003fc  1940              ADDS     r0,r0,r5
;;;485            count = count - encode_count;
0003fe  9003              STR      r0,[sp,#0xc]
000400  9802              LDR      r0,[sp,#8]
000402  1b40              SUBS     r0,r0,r5
;;;486            if( ((line_ctr == LINE_CHECKSUM) || (count == 0)) )
000404  2c14              CMP      r4,#0x14
000406  9002              STR      r0,[sp,#8]
000408  d001              BEQ      |L1.1038|
00040a  2800              CMP      r0,#0
00040c  d11d              BNE      |L1.1098|
                  |L1.1038|
;;;487            {
;;;488                /* Tranmitt checksum string (ASCII decimal) to host */
;;;489                sendline_crlf(i_to_a(checksum,cmd_buf,PARAM_SIZE));
00040e  4923              LDR      r1,|L1.1180|
000410  220f              MOVS     r2,#0xf
000412  0030              MOVS     r0,r6
000414  f7fffffe          BL       i_to_a
000418  f7fffffe          BL       sendline_crlf
;;;490                /* Read host response */
;;;491                rc = getline(cmd_buf,CMD_SIZE,&char_cnt);
00041c  481f              LDR      r0,|L1.1180|
00041e  2146              MOVS     r1,#0x46
000420  466a              MOV      r2,sp
000422  f7fffffe          BL       getline
;;;492                if( rc != CMD_SUCCESS)
000426  2800              CMP      r0,#0
000428  d1b4              BNE      |L1.916|
;;;493                {
;;;494                    break;
;;;495                }
;;;496                if(str_cmp(cmd_buf,(char *)ok) == 0)
00042a  491d              LDR      r1,|L1.1184|
00042c  481b              LDR      r0,|L1.1180|
00042e  390a              SUBS     r1,r1,#0xa
000430  f7fffffe          BL       str_cmp
000434  2800              CMP      r0,#0
000436  d103              BNE      |L1.1088|
;;;497                {
;;;498                    last_cnt = count;
000438  9802              LDR      r0,[sp,#8]
;;;499                    last_src = src;
00043a  9f03              LDR      r7,[sp,#0xc]
00043c  9001              STR      r0,[sp,#4]
00043e  e002              B        |L1.1094|
                  |L1.1088|
;;;500                }
;;;501                else
;;;502                {
;;;503                    count = last_cnt;
000440  9801              LDR      r0,[sp,#4]
;;;504                    src = last_src;
000442  a902              ADD      r1,sp,#8
000444  c181              STM      r1!,{r0,r7}
                  |L1.1094|
;;;505                }
;;;506                /* line counter and checksum has to be reset anyway */
;;;507                line_ctr = 0;
000446  2400              MOVS     r4,#0
;;;508                checksum = 0;
000448  0026              MOVS     r6,r4
                  |L1.1098|
00044a  9d02              LDR      r5,[sp,#8]            ;465
00044c  2d00              CMP      r5,#0                 ;465
00044e  dcc5              BGT      |L1.988|
;;;509            }
;;;510        } /* while count > 0 */
;;;511    } /* read */
000450  e7a0              B        |L1.916|
;;;512    
                          ENDP

                  go_cmd PROC
;;;513    void go_cmd(void)
000452  b538              PUSH     {r3-r5,lr}
;;;514    {
;;;515        unsigned rc;
;;;516        void (*go)(void);
;;;517        
;;;518        if(lock == FALSE)
000454  4815              LDR      r0,|L1.1196|
;;;519        {
;;;520            rc = CMD_SUCCESS;
;;;521        }
;;;522        else
;;;523        {
;;;524            rc = CMD_LOCKED;
;;;525        }
;;;526            
;;;527        if(rc == CMD_SUCCESS)
;;;528        {
;;;529            /* Convert and check Go addres */
;;;530            rc = param_check(param_buf[ISP_PARAM_1],(unsigned *)&go, \
000456  4d11              LDR      r5,|L1.1180|
000458  6800              LDR      r0,[r0,#0]            ;518  ; lock
00045a  3594              ADDS     r5,r5,#0x94
00045c  2800              CMP      r0,#0                 ;518
00045e  d12c              BNE      |L1.1210|
000460  6868              LDR      r0,[r5,#4]  ; param_buf
000462  2266              MOVS     r2,#0x66
000464  2300              MOVS     r3,#0
000466  4669              MOV      r1,sp
000468  f7fffffe          BL       param_check
00046c  0004              MOVS     r4,r0
;;;531                 RAM_OR_FLASH_ADDRESS,NUL);
;;;532        }
;;;533        
;;;534        if(rc == CMD_SUCCESS)
00046e  d106              BNE      |L1.1150|
;;;535        {
;;;536            /* Check for processor mode switch */
;;;537            if( ((*(param_buf[ISP_PARAM_2]) == 'T') || (*(param_buf[ISP_PARAM_2]) == 'A')) )
000470  68a8              LDR      r0,[r5,#8]  ; param_buf
000472  7800              LDRB     r0,[r0,#0]
000474  2854              CMP      r0,#0x54
000476  d022              BEQ      |L1.1214|
000478  2841              CMP      r0,#0x41
00047a  d000              BEQ      |L1.1150|
;;;538            {
;;;539                if(*(param_buf[ISP_PARAM_2]) == 'T')
;;;540                {
;;;541                    /* ARM Thumb compiler generates BX instruction when pointer 
;;;542                    to a function is used. Set last bit of the address to 1 
;;;543                    to prevent mode switch to ARM */
;;;544                    go = (void(*)(void))( ((unsigned)(go) | 0x1) );
;;;545                }
;;;546                /* else For ARM mode leave last bit of the address 0 */
;;;547            }
;;;548            else
;;;549            {
;;;550                /* Mode parameter is not specified or incorrect */
;;;551                rc = PARAM_ERROR;
00047c  240c              MOVS     r4,#0xc
                  |L1.1150|
;;;552            }
;;;553        }
;;;554        /* Print command result on serial channel */
;;;555        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_1],PARAM_SIZE));
00047e  6869              LDR      r1,[r5,#4]  ; param_buf
000480  220f              MOVS     r2,#0xf
000482  0020              MOVS     r0,r4
000484  f7fffffe          BL       i_to_a
000488  f7fffffe          BL       sendline_crlf
;;;556        /* execute command only if all the parameters are ok */
;;;557        if(rc == CMD_SUCCESS)
00048c  2c00              CMP      r4,#0
00048e  d104              BNE      |L1.1178|
;;;558        {
;;;559    	    /* revert any peripheral changes */
;;;560            Timer_DeInit();
000490  f7fffffe          BL       Timer_DeInit
;;;561            go();
000494  9800              LDR      r0,[sp,#0]
000496  f7fffffe          BL       __ARM_common_call_via_r0
                  |L1.1178|
;;;562        }
;;;563    } /* go */
00049a  e00b              B        |L1.1204|
                  |L1.1180|
                          DCD      ||.bss||
                  |L1.1184|
                          DCD      ||area_number.6||+0xa
                  |L1.1188|
                          DCD      0x40010000
                  |L1.1192|
                          DCD      0x7ffffff1
                  |L1.1196|
                          DCD      ||.data||
                  |L1.1200|
                          DCD      0x12345678
                  |L1.1204|
0004b4  bc38              POP      {r3-r5}
0004b6  bc08              POP      {r3}
0004b8  4718              BX       r3
                  |L1.1210|
0004ba  240f              MOVS     r4,#0xf               ;524
0004bc  e7df              B        |L1.1150|
                  |L1.1214|
0004be  9800              LDR      r0,[sp,#0]            ;544
0004c0  2101              MOVS     r1,#1                 ;544
0004c2  4308              ORRS     r0,r0,r1              ;544
0004c4  9000              STR      r0,[sp,#0]            ;544
0004c6  e7da              B        |L1.1150|
;;;564    
                          ENDP

                  unlock PROC
;;;565    void unlock(void)
0004c8  b538              PUSH     {r3-r5,lr}
;;;566    {
;;;567        int u_code;
;;;568        unsigned rc;
;;;569        rc = param_check(param_buf[ISP_PARAM_1],(unsigned *)&u_code,NO_PARAM_CHECK,NUL);
0004ca  4cfd              LDR      r4,|L1.2240|
0004cc  2269              MOVS     r2,#0x69
0004ce  6860              LDR      r0,[r4,#4]  ; param_buf
0004d0  2300              MOVS     r3,#0
0004d2  4669              MOV      r1,sp
0004d4  f7fffffe          BL       param_check
;;;570        /* execute command only if parameters are ok */
;;;571        if(rc == 0)
0004d8  2800              CMP      r0,#0
0004da  d108              BNE      |L1.1262|
;;;572        {
;;;573            if(u_code == unlock_code)
0004dc  4af9              LDR      r2,|L1.2244|
0004de  9900              LDR      r1,[sp,#0]
0004e0  4291              CMP      r1,r2
0004e2  d103              BNE      |L1.1260|
;;;574            {
;;;575                lock = FALSE;    
0004e4  4af8              LDR      r2,|L1.2248|
0004e6  2100              MOVS     r1,#0
0004e8  6011              STR      r1,[r2,#0]  ; lock
0004ea  e000              B        |L1.1262|
                  |L1.1260|
;;;576            }
;;;577            else
;;;578            {
;;;579                rc = INVALID_CODE;
0004ec  2010              MOVS     r0,#0x10
                  |L1.1262|
;;;580            }
;;;581        }
;;;582        /* Print command result on serial channel */
;;;583        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_1],PARAM_SIZE));
0004ee  6861              LDR      r1,[r4,#4]  ; param_buf
0004f0  220f              MOVS     r2,#0xf
0004f2  f7fffffe          BL       i_to_a
0004f6  f7fffffe          BL       sendline_crlf
;;;584    } /* unlock */
0004fa  e7ce              B        |L1.1178|
;;;585    
                          ENDP

                  prepare_sector PROC
;;;586    void prepare_sector(void)
0004fc  b570              PUSH     {r4-r6,lr}
;;;587    {
;;;588        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;589           done in IAP prepare sector for write. Parameter type is deliberately 
;;;590           set to NO_PARAM_CHECK so that param_check function just converts ascii 
;;;591           to integer 
;;;592        */
;;;593        result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
0004fe  4cf0              LDR      r4,|L1.2240|
000500  2269              MOVS     r2,#0x69
000502  0026              MOVS     r6,r4
000504  3614              ADDS     r6,r6,#0x14
000506  6860              LDR      r0,[r4,#4]  ; param_buf
000508  1d31              ADDS     r1,r6,#4
00050a  2300              MOVS     r3,#0
00050c  f7fffffe          BL       param_check
000510  0025              MOVS     r5,r4
000512  3528              ADDS     r5,r5,#0x28
;;;594        &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;595    
;;;596        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000514  2800              CMP      r0,#0
000516  6028              STR      r0,[r5,#0]  ; result_table
000518  d110              BNE      |L1.1340|
;;;597        {
;;;598            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
00051a  0021              MOVS     r1,r4
00051c  68a0              LDR      r0,[r4,#8]  ; param_buf
00051e  2269              MOVS     r2,#0x69
000520  311c              ADDS     r1,r1,#0x1c
000522  2300              MOVS     r3,#0
000524  f7fffffe          BL       param_check
;;;599            &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;600        }
;;;601            
;;;602        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000528  2800              CMP      r0,#0
00052a  6028              STR      r0,[r5,#0]  ; result_table
00052c  d106              BNE      |L1.1340|
;;;603        {
;;;604            param_table[IAP_CMD_CODE] = PREPARE_SECTOR_FOR_WRITE;
00052e  2032              MOVS     r0,#0x32
000530  6030              STR      r0,[r6,#0]  ; param_table
000532  4ae6              LDR      r2,|L1.2252|
000534  0029              MOVS     r1,r5
000536  0030              MOVS     r0,r6
000538  f7fffffe          BL       __ARM_common_call_via_r2
                  |L1.1340|
;;;605            iap_entry(param_table,result_table);
;;;606        }
;;;607        sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
00053c  6861              LDR      r1,[r4,#4]  ; param_buf
00053e  6828              LDR      r0,[r5,#0]  ; result_table
000540  220f              MOVS     r2,#0xf
000542  f7fffffe          BL       i_to_a
000546  f7fffffe          BL       sendline_crlf
                  |L1.1354|
;;;608        PARAM_SIZE));
;;;609    } /* prepare_sector */
00054a  e5a1              B        |L1.144|
;;;610    
                          ENDP

                  copy PROC
;;;611    void copy(void)
00054c  b5f8              PUSH     {r3-r7,lr}
;;;612    {
;;;613        if(lock == TRUE)
00054e  4ede              LDR      r6,|L1.2248|
;;;614        {
;;;615            sendline_crlf(i_to_a(CMD_LOCKED,param_buf[ISP_PARAM_1],PARAM_SIZE));
000550  4fdb              LDR      r7,|L1.2240|
000552  6831              LDR      r1,[r6,#0]  ; lock
000554  6878              LDR      r0,[r7,#4]            ;613
000556  2901              CMP      r1,#1                 ;613
000558  d103              BNE      |L1.1378|
00055a  220f              MOVS     r2,#0xf
00055c  0001              MOVS     r1,r0
00055e  0010              MOVS     r0,r2
000560  e03b              B        |L1.1498|
                  |L1.1378|
;;;616        }
;;;617        else
;;;618        {
;;;619        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;620        done in IAP copy RAM to FLASH.Parameter type is deliberately 
;;;621        set to NO_PARAM_CHECK so that param_check function just converts ascii to integer
;;;622        */
;;;623            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
000562  4dd7              LDR      r5,|L1.2240|
000564  2269              MOVS     r2,#0x69
000566  3514              ADDS     r5,r5,#0x14
000568  1d29              ADDS     r1,r5,#4
00056a  2300              MOVS     r3,#0
00056c  f7fffffe          BL       param_check
000570  002c              MOVS     r4,r5
000572  3414              ADDS     r4,r4,#0x14
;;;624            &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;625    
;;;626            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000574  2800              CMP      r0,#0
000576  6020              STR      r0,[r4,#0]  ; result_table
000578  d111              BNE      |L1.1438|
;;;627            {
;;;628                result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
00057a  0021              MOVS     r1,r4
00057c  68b8              LDR      r0,[r7,#8]  ; param_buf
00057e  2269              MOVS     r2,#0x69
000580  390c              SUBS     r1,r1,#0xc
000582  2300              MOVS     r3,#0
000584  f7fffffe          BL       param_check
;;;629                &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;630            }
;;;631    
;;;632            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000588  2800              CMP      r0,#0
00058a  6020              STR      r0,[r4,#0]  ; result_table
00058c  d107              BNE      |L1.1438|
;;;633            {
;;;634                result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_3], \
00058e  0021              MOVS     r1,r4
000590  68f8              LDR      r0,[r7,#0xc]  ; param_buf
000592  2269              MOVS     r2,#0x69
000594  3908              SUBS     r1,r1,#8
000596  2300              MOVS     r3,#0
000598  f7fffffe          BL       param_check
00059c  6020              STR      r0,[r4,#0]  ; result_table
                  |L1.1438|
;;;635                &param_table[IAP_PARAM_2],NO_PARAM_CHECK,NUL);
;;;636            }
;;;637    
;;;638            /* Do not allow write to USER Start sector */
;;;639            if( (crp_after_reset == CRP1) )
00059e  49cc              LDR      r1,|L1.2256|
0005a0  6870              LDR      r0,[r6,#4]  ; crp_after_reset
0005a2  4288              CMP      r0,r1
0005a4  d107              BNE      |L1.1462|
;;;640            {
;;;641                if( (param_table[IAP_PARAM_0] < (USER_START_SECTOR_ADDRESS+USER_START_SECTOR_SIZE)) )
0005a6  6868              LDR      r0,[r5,#4]  ; param_table
0005a8  2103              MOVS     r1,#3
0005aa  0309              LSLS     r1,r1,#12
0005ac  4288              CMP      r0,r1
0005ae  d202              BCS      |L1.1462|
;;;642                {
;;;643                    result_table[IAP_STAT_CODE] = CODE_READ_PROTECTION_ENABLED;
0005b0  2013              MOVS     r0,#0x13
0005b2  6020              STR      r0,[r4,#0]  ; result_table
0005b4  e00e              B        |L1.1492|
                  |L1.1462|
;;;644                }
;;;645            }
;;;646    
;;;647            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0005b6  6820              LDR      r0,[r4,#0]  ; result_table
0005b8  2800              CMP      r0,#0
0005ba  d10b              BNE      |L1.1492|
;;;648            {
;;;649                param_table[IAP_CMD_CODE] = COPY_RAM_TO_FLASH;
0005bc  2033              MOVS     r0,#0x33
;;;650                param_table[IAP_PARAM_3] = fcclk_KHz;
0005be  6028              STR      r0,[r5,#0]  ; param_table
0005c0  48c4              LDR      r0,|L1.2260|
0005c2  49bf              LDR      r1,|L1.2240|
0005c4  6800              LDR      r0,[r0,#0]  ; fcclk_KHz
0005c6  3128              ADDS     r1,r1,#0x28
0005c8  6128              STR      r0,[r5,#0x10]  ; param_table
0005ca  0008              MOVS     r0,r1
0005cc  4abf              LDR      r2,|L1.2252|
0005ce  3814              SUBS     r0,r0,#0x14
0005d0  f7fffffe          BL       __ARM_common_call_via_r2
                  |L1.1492|
;;;651                iap_entry(param_table,result_table);
;;;652            }
;;;653            sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
0005d4  6879              LDR      r1,[r7,#4]  ; param_buf
0005d6  6820              LDR      r0,[r4,#0]  ; result_table
0005d8  220f              MOVS     r2,#0xf
                  |L1.1498|
0005da  f7fffffe          BL       i_to_a
0005de  f7fffffe          BL       sendline_crlf
                  |L1.1506|
;;;654            PARAM_SIZE));
;;;655        }
;;;656    } /* copy */
0005e2  bcf8              POP      {r3-r7}
0005e4  bc08              POP      {r3}
0005e6  4718              BX       r3
;;;657    
                          ENDP

                  erase PROC
;;;658    void erase(void)
0005e8  b5f8              PUSH     {r3-r7,lr}
;;;659    {
;;;660        if(lock == TRUE)
0005ea  4eb7              LDR      r6,|L1.2248|
;;;661        {
;;;662            sendline_crlf(i_to_a(CMD_LOCKED,param_buf[ISP_PARAM_1],PARAM_SIZE));
0005ec  4fb4              LDR      r7,|L1.2240|
0005ee  6831              LDR      r1,[r6,#0]  ; lock
0005f0  6878              LDR      r0,[r7,#4]            ;660
0005f2  2901              CMP      r1,#1                 ;660
0005f4  d103              BNE      |L1.1534|
0005f6  220f              MOVS     r2,#0xf
0005f8  0001              MOVS     r1,r0
0005fa  0010              MOVS     r0,r2
0005fc  e048              B        |L1.1680|
                  |L1.1534|
;;;663        }
;;;664        else
;;;665        {
;;;666        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;667           done in IAP erase sector. Parameter type is deliberately 
;;;668           set to NO_PARAM_CHECK so that param_check function just converts ascii to integer 
;;;669        */
;;;670            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
0005fe  4db0              LDR      r5,|L1.2240|
000600  2269              MOVS     r2,#0x69
000602  3514              ADDS     r5,r5,#0x14
000604  1d29              ADDS     r1,r5,#4
000606  2300              MOVS     r3,#0
000608  f7fffffe          BL       param_check
00060c  002c              MOVS     r4,r5
00060e  3414              ADDS     r4,r4,#0x14
;;;671            &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;672    
;;;673            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000610  2800              CMP      r0,#0
000612  6020              STR      r0,[r4,#0]  ; result_table
000614  d107              BNE      |L1.1574|
;;;674            {
;;;675                result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
000616  0021              MOVS     r1,r4
000618  68b8              LDR      r0,[r7,#8]  ; param_buf
00061a  2269              MOVS     r2,#0x69
00061c  390c              SUBS     r1,r1,#0xc
00061e  2300              MOVS     r3,#0
000620  f7fffffe          BL       param_check
000624  6020              STR      r0,[r4,#0]  ; result_table
                  |L1.1574|
;;;676                &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;677            }
;;;678    
;;;679            /* If code read protection level 2 or 3 is enabled allow erase command only when
;;;680               all sectors are selected for erase */
;;;681            if( (crp_after_reset == CRP2) ||                     \
000626  4aac              LDR      r2,|L1.2264|
000628  6870              LDR      r0,[r6,#4]  ; crp_after_reset
;;;682                (crp_after_reset == CRP3) 
;;;683               )
;;;684            {
;;;685                if( (param_table[IAP_PARAM_0] != USER_START_SECTOR) ||                         \
;;;686                    (param_table[IAP_PARAM_1] != USER_END_SECTOR)
;;;687                  )
;;;688                {
;;;689                    result_table[IAP_STAT_CODE] = CODE_READ_PROTECTION_ENABLED;
00062a  2113              MOVS     r1,#0x13
00062c  4290              CMP      r0,r2                 ;681
00062e  d002              BEQ      |L1.1590|
000630  4aaa              LDR      r2,|L1.2268|
000632  4290              CMP      r0,r2                 ;682
000634  d107              BNE      |L1.1606|
                  |L1.1590|
000636  6868              LDR      r0,[r5,#4]            ;685  ; param_table
000638  2802              CMP      r0,#2                 ;685
00063a  d102              BNE      |L1.1602|
00063c  68a8              LDR      r0,[r5,#8]            ;686  ; param_table
00063e  281b              CMP      r0,#0x1b              ;686
000640  d00c              BEQ      |L1.1628|
                  |L1.1602|
000642  6021              STR      r1,[r4,#0]  ; result_table
000644  e019              B        |L1.1658|
                  |L1.1606|
;;;690                }
;;;691            }
;;;692    
;;;693            /* If code read protection level 1 is enabled allow erase command only when
;;;694               user start sector is NOT selected for erase */
;;;695            else if( (crp_after_reset == CRP1) )
000646  4aa2              LDR      r2,|L1.2256|
000648  4290              CMP      r0,r2
00064a  d107              BNE      |L1.1628|
;;;696            {
;;;697               if( (param_table[IAP_PARAM_0] == USER_START_SECTOR) &&                         \
00064c  6868              LDR      r0,[r5,#4]  ; param_table
00064e  2802              CMP      r0,#2
000650  d104              BNE      |L1.1628|
;;;698                   (param_table[IAP_PARAM_1] != USER_END_SECTOR)
000652  68a8              LDR      r0,[r5,#8]  ; param_table
000654  281b              CMP      r0,#0x1b
000656  d001              BEQ      |L1.1628|
;;;699                 )
;;;700                {
;;;701                    result_table[IAP_STAT_CODE] = CODE_READ_PROTECTION_ENABLED;
000658  6021              STR      r1,[r4,#0]  ; result_table
00065a  e016              B        |L1.1674|
                  |L1.1628|
;;;702                }
;;;703            }
;;;704    
;;;705            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
00065c  6820              LDR      r0,[r4,#0]  ; result_table
00065e  2800              CMP      r0,#0
000660  d10b              BNE      |L1.1658|
;;;706            {
;;;707                param_table[IAP_CMD_CODE] = ERASE_SECTOR;
000662  2034              MOVS     r0,#0x34
;;;708                param_table[IAP_PARAM_2] = fcclk_KHz;
000664  6028              STR      r0,[r5,#0]  ; param_table
000666  489b              LDR      r0,|L1.2260|
000668  4995              LDR      r1,|L1.2240|
00066a  6800              LDR      r0,[r0,#0]  ; fcclk_KHz
00066c  3128              ADDS     r1,r1,#0x28
00066e  60e8              STR      r0,[r5,#0xc]  ; param_table
000670  0008              MOVS     r0,r1
000672  4a96              LDR      r2,|L1.2252|
000674  3814              SUBS     r0,r0,#0x14
000676  f7fffffe          BL       __ARM_common_call_via_r2
                  |L1.1658|
;;;709                iap_entry(param_table,result_table);
;;;710            }
;;;711            /* Update code protection status if all sectors are erased */
;;;712            if( (param_table[IAP_PARAM_0] == USER_START_SECTOR) &&                         \
00067a  6868              LDR      r0,[r5,#4]  ; param_table
00067c  2802              CMP      r0,#2
00067e  d104              BNE      |L1.1674|
;;;713                (param_table[IAP_PARAM_1] == USER_END_SECTOR)
000680  68a8              LDR      r0,[r5,#8]  ; param_table
000682  281b              CMP      r0,#0x1b
000684  d101              BNE      |L1.1674|
;;;714              )
;;;715            {
;;;716                crp_after_reset = NOCRP;       
000686  4896              LDR      r0,|L1.2272|
000688  6070              STR      r0,[r6,#4]  ; crp_after_reset
                  |L1.1674|
;;;717            }
;;;718            sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
00068a  6879              LDR      r1,[r7,#4]  ; param_buf
00068c  6820              LDR      r0,[r4,#0]  ; result_table
00068e  220f              MOVS     r2,#0xf
                  |L1.1680|
000690  f7fffffe          BL       i_to_a
000694  f7fffffe          BL       sendline_crlf
;;;719            PARAM_SIZE));
;;;720        }
;;;721    } /* erase */
000698  e7a3              B        |L1.1506|
;;;722    
                          ENDP

                  blank_check PROC
;;;723    void blank_check(void)
00069a  b570              PUSH     {r4-r6,lr}
;;;724    {
;;;725        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;726           done in IAP blank check sector. Parameter type is deliberately 
;;;727           set to NO_PARAM_CHECK so that param_check function just converts ascii 
;;;728           to integer
;;;729        */
;;;730        result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
00069c  4c88              LDR      r4,|L1.2240|
00069e  2269              MOVS     r2,#0x69
0006a0  0026              MOVS     r6,r4
0006a2  3614              ADDS     r6,r6,#0x14
0006a4  6860              LDR      r0,[r4,#4]  ; param_buf
0006a6  1d31              ADDS     r1,r6,#4
0006a8  2300              MOVS     r3,#0
0006aa  f7fffffe          BL       param_check
0006ae  0025              MOVS     r5,r4
0006b0  3528              ADDS     r5,r5,#0x28
;;;731        &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;732        
;;;733        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0006b2  2800              CMP      r0,#0
0006b4  6028              STR      r0,[r5,#0]  ; result_table
0006b6  d110              BNE      |L1.1754|
;;;734        {
;;;735            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
0006b8  0021              MOVS     r1,r4
0006ba  68a0              LDR      r0,[r4,#8]  ; param_buf
0006bc  2269              MOVS     r2,#0x69
0006be  311c              ADDS     r1,r1,#0x1c
0006c0  2300              MOVS     r3,#0
0006c2  f7fffffe          BL       param_check
;;;736            &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;737        }    
;;;738        
;;;739        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0006c6  2800              CMP      r0,#0
0006c8  6028              STR      r0,[r5,#0]  ; result_table
0006ca  d106              BNE      |L1.1754|
;;;740        {
;;;741            param_table[IAP_CMD_CODE] = BLANK_CHECK_SECTOR;
0006cc  2035              MOVS     r0,#0x35
0006ce  6030              STR      r0,[r6,#0]  ; param_table
0006d0  4a7e              LDR      r2,|L1.2252|
0006d2  0029              MOVS     r1,r5
0006d4  0030              MOVS     r0,r6
0006d6  f7fffffe          BL       __ARM_common_call_via_r2
                  |L1.1754|
;;;742            iap_entry(param_table,result_table);
;;;743        }
;;;744        sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
0006da  6861              LDR      r1,[r4,#4]  ; param_buf
0006dc  6828              LDR      r0,[r5,#0]  ; result_table
0006de  220f              MOVS     r2,#0xf
0006e0  f7fffffe          BL       i_to_a
0006e4  f7fffffe          BL       sendline_crlf
;;;745        PARAM_SIZE));
;;;746        if(result_table[IAP_STAT_CODE] == SECTOR_NOT_BLANK)
0006e8  6828              LDR      r0,[r5,#0]  ; result_table
0006ea  2808              CMP      r0,#8
0006ec  d11b              BNE      |L1.1830|
;;;747        {
;;;748            if( ( (crp_after_reset == CRP1)       ||       \
0006ee  4876              LDR      r0,|L1.2248|
0006f0  4977              LDR      r1,|L1.2256|
0006f2  6840              LDR      r0,[r0,#4]  ; crp_after_reset
0006f4  4288              CMP      r0,r1
0006f6  d005              BEQ      |L1.1796|
;;;749                  (crp_after_reset == CRP2)       ||       \
0006f8  4977              LDR      r1,|L1.2264|
0006fa  4288              CMP      r0,r1
0006fc  d002              BEQ      |L1.1796|
;;;750                  (crp_after_reset == CRP3) )              \
0006fe  4977              LDR      r1,|L1.2268|
000700  4288              CMP      r0,r1
000702  d102              BNE      |L1.1802|
                  |L1.1796|
;;;751              )
;;;752            {
;;;753                result_table[IAP_RESULT_0]=0;
000704  2000              MOVS     r0,#0
;;;754                result_table[IAP_RESULT_1]=0;
000706  6068              STR      r0,[r5,#4]  ; result_table
000708  60a8              STR      r0,[r5,#8]  ; result_table
                  |L1.1802|
;;;755            }
;;;756            sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
00070a  6861              LDR      r1,[r4,#4]  ; param_buf
00070c  6868              LDR      r0,[r5,#4]  ; result_table
00070e  220f              MOVS     r2,#0xf
000710  f7fffffe          BL       i_to_a
000714  f7fffffe          BL       sendline_crlf
;;;757            PARAM_SIZE));
;;;758            sendline_crlf(i_to_a(result_table[IAP_RESULT_1],param_buf[ISP_PARAM_1], \
000718  6861              LDR      r1,[r4,#4]  ; param_buf
00071a  68a8              LDR      r0,[r5,#8]  ; result_table
00071c  220f              MOVS     r2,#0xf
00071e  f7fffffe          BL       i_to_a
000722  f7fffffe          BL       sendline_crlf
                  |L1.1830|
;;;759            PARAM_SIZE));
;;;760        }
;;;761    } /* blank_check */
000726  e4b3              B        |L1.144|
;;;762    
                          ENDP

                  compare_mem PROC
;;;763    void compare_mem(void)
000728  b570              PUSH     {r4-r6,lr}
;;;764    {
;;;765        /* Convert ascii string to integer. Do not validate address & count as it is
;;;766        done in IAP COMPARE command.Parameter type is deliberately 
;;;767        set to NO_PARAM_CHECK so that param_check function just converts ascii to integer
;;;768        */
;;;769        result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
00072a  4c65              LDR      r4,|L1.2240|
00072c  2269              MOVS     r2,#0x69
00072e  0026              MOVS     r6,r4
000730  3614              ADDS     r6,r6,#0x14
000732  6860              LDR      r0,[r4,#4]  ; param_buf
000734  1d31              ADDS     r1,r6,#4
000736  2300              MOVS     r3,#0
000738  f7fffffe          BL       param_check
00073c  0025              MOVS     r5,r4
00073e  3528              ADDS     r5,r5,#0x28
;;;770        &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;771    
;;;772        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000740  2800              CMP      r0,#0
000742  6028              STR      r0,[r5,#0]  ; result_table
000744  d11a              BNE      |L1.1916|
;;;773        {
;;;774            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
000746  0021              MOVS     r1,r4
000748  68a0              LDR      r0,[r4,#8]  ; param_buf
00074a  2269              MOVS     r2,#0x69
00074c  311c              ADDS     r1,r1,#0x1c
00074e  2300              MOVS     r3,#0
000750  f7fffffe          BL       param_check
;;;775            &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;776        }
;;;777    
;;;778        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000754  2800              CMP      r0,#0
000756  6028              STR      r0,[r5,#0]  ; result_table
000758  d110              BNE      |L1.1916|
;;;779        {
;;;780            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_3], \
00075a  0021              MOVS     r1,r4
00075c  68e0              LDR      r0,[r4,#0xc]  ; param_buf
00075e  2269              MOVS     r2,#0x69
000760  3120              ADDS     r1,r1,#0x20
000762  2300              MOVS     r3,#0
000764  f7fffffe          BL       param_check
;;;781            &param_table[IAP_PARAM_2],NO_PARAM_CHECK,NUL);
;;;782        }
;;;783    
;;;784        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000768  2800              CMP      r0,#0
00076a  6028              STR      r0,[r5,#0]  ; result_table
00076c  d106              BNE      |L1.1916|
;;;785        {
;;;786            param_table[IAP_CMD_CODE] = COMPARE;
00076e  2038              MOVS     r0,#0x38
000770  6030              STR      r0,[r6,#0]  ; param_table
000772  4a56              LDR      r2,|L1.2252|
000774  0029              MOVS     r1,r5
000776  0030              MOVS     r0,r6
000778  f7fffffe          BL       __ARM_common_call_via_r2
                  |L1.1916|
;;;787            iap_entry(param_table,result_table);
;;;788        }
;;;789        sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
00077c  6861              LDR      r1,[r4,#4]  ; param_buf
00077e  6828              LDR      r0,[r5,#0]  ; result_table
000780  220f              MOVS     r2,#0xf
000782  f7fffffe          BL       i_to_a
000786  f7fffffe          BL       sendline_crlf
;;;790        PARAM_SIZE));
;;;791        if(result_table[IAP_STAT_CODE] == COMPARE_ERROR)
00078a  6828              LDR      r0,[r5,#0]  ; result_table
00078c  280a              CMP      r0,#0xa
00078e  d106              BNE      |L1.1950|
;;;792        {
;;;793            sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
000790  6861              LDR      r1,[r4,#4]  ; param_buf
000792  6868              LDR      r0,[r5,#4]  ; result_table
000794  220f              MOVS     r2,#0xf
000796  f7fffffe          BL       i_to_a
00079a  f7fffffe          BL       sendline_crlf
                  |L1.1950|
;;;794            PARAM_SIZE));
;;;795        }
;;;796    }
00079e  e477              B        |L1.144|
;;;797    
                          ENDP

                  tokenize PROC
;;;798    int tokenize(char * in_buf,int no_of_chars_in_inbuf,char * out_buf[],   \
0007a0  b5ff              PUSH     {r0-r7,lr}
;;;799                 int max_tokens,int max_chars_per_token )
;;;800    {
0007a2  4684              MOV      r12,r0
;;;801        int i,token_count=0,pos=0, chars_in_token=0;
;;;802    
;;;803        if(in_buf[0] == NUL)
0007a4  4661              MOV      r1,r12
0007a6  7809              LDRB     r1,[r1,#0]
0007a8  2000              MOVS     r0,#0                 ;801
0007aa  469e              MOV      lr,r3                 ;800
0007ac  9d09              LDR      r5,[sp,#0x24]
0007ae  0003              MOVS     r3,r0                 ;801
0007b0  0004              MOVS     r4,r0                 ;801
0007b2  2900              CMP      r1,#0
0007b4  d101              BNE      |L1.1978|
                  |L1.1974|
;;;804        {
;;;805            return(0);
;;;806        }
;;;807        for(i=0;i<=no_of_chars_in_inbuf;i++)
;;;808        {
;;;809            if( token_count+1 > max_tokens)
;;;810            {
;;;811                return(token_count+1);
;;;812            }
;;;813            
;;;814            if( (in_buf[i] != SP)  &&                                      \
;;;815                (chars_in_token < (max_chars_per_token -2)) )
;;;816            {
;;;817                *(out_buf[token_count]+pos) = in_buf[i];
;;;818                pos++;
;;;819                chars_in_token++;
;;;820            }
;;;821            else if( (in_buf[i+1] != SP) ||                                \
;;;822                     (chars_in_token == (max_chars_per_token -2)) )
;;;823            {
;;;824                *(out_buf[token_count]+pos) = NUL;
;;;825                token_count++;
;;;826                pos=0;
;;;827                chars_in_token=0;
;;;828            }            
;;;829        }
;;;830        return(token_count+1);
;;;831    } /* tokenize */
0007b6  b004              ADD      sp,sp,#0x10
0007b8  e48f              B        |L1.218|
                  |L1.1978|
0007ba  2100              MOVS     r1,#0                 ;807
0007bc  1ead              SUBS     r5,r5,#2              ;815
0007be  e01c              B        |L1.2042|
                  |L1.1984|
0007c0  1c46              ADDS     r6,r0,#1              ;809
0007c2  4576              CMP      r6,lr                 ;809
0007c4  dc1c              BGT      |L1.2048|
0007c6  4666              MOV      r6,r12                ;814
0007c8  5c76              LDRB     r6,[r6,r1]            ;814
0007ca  2e20              CMP      r6,#0x20              ;814
0007cc  d007              BEQ      |L1.2014|
0007ce  42ac              CMP      r4,r5                 ;815
0007d0  da05              BGE      |L1.2014|
0007d2  0087              LSLS     r7,r0,#2              ;815
0007d4  59d7              LDR      r7,[r2,r7]            ;817
0007d6  54fe              STRB     r6,[r7,r3]            ;817
0007d8  1c5b              ADDS     r3,r3,#1              ;818
0007da  1c64              ADDS     r4,r4,#1              ;819
0007dc  e00c              B        |L1.2040|
                  |L1.2014|
0007de  4666              MOV      r6,r12                ;821
0007e0  1876              ADDS     r6,r6,r1              ;821
0007e2  7876              LDRB     r6,[r6,#1]            ;821
0007e4  2e20              CMP      r6,#0x20              ;821
0007e6  d101              BNE      |L1.2028|
0007e8  42ac              CMP      r4,r5                 ;822
0007ea  d105              BNE      |L1.2040|
                  |L1.2028|
0007ec  0086              LSLS     r6,r0,#2              ;824
0007ee  5996              LDR      r6,[r2,r6]            ;824
0007f0  2400              MOVS     r4,#0                 ;824
0007f2  1c40              ADDS     r0,r0,#1              ;825
0007f4  54f4              STRB     r4,[r6,r3]            ;824
0007f6  0023              MOVS     r3,r4                 ;826
                  |L1.2040|
0007f8  1c49              ADDS     r1,r1,#1              ;807
                  |L1.2042|
0007fa  9e01              LDR      r6,[sp,#4]            ;807
0007fc  42b1              CMP      r1,r6                 ;807
0007fe  dddf              BLE      |L1.1984|
                  |L1.2048|
000800  1c40              ADDS     r0,r0,#1              ;830
000802  e7d8              B        |L1.1974|
;;;832    
                          ENDP

                  enable_interrupts PROC
;;;833    void enable_interrupts(unsigned interrupts)
000804  4937              LDR      r1,|L1.2276|
;;;834    {
;;;835        VICIntEnable = interrupts;
000806  6108              STR      r0,[r1,#0x10]
;;;836    }
000808  4770              BX       lr
;;;837    
                          ENDP

                  disable_interrupts PROC
;;;838    void disable_interrupts(unsigned interrupts)
00080a  4936              LDR      r1,|L1.2276|
;;;839    {
;;;840        VICIntEnClr = interrupts;
00080c  6148              STR      r0,[r1,#0x14]
;;;841    }
00080e  4770              BX       lr
;;;842    
                          ENDP

                  execute_user_code PROC
;;;843    void execute_user_code(void)
000810  2001              MOVS     r0,#1
;;;844    {
;;;845        void (*user_code_entry)(void);
;;;846        user_code_entry = (void (*)(void))USER_START_SECTOR_ADDRESS;
000812  0340              LSLS     r0,r0,#13
;;;847        user_code_entry();
000814  4700              BX       r0
;;;848    }
;;;849    
                          ENDP

                  user_code_present PROC
;;;850    unsigned user_code_present(void)
000816  482a              LDR      r0,|L1.2240|
;;;851    {
000818  b510              PUSH     {r4,lr}
;;;852        param_table[IAP_CMD_CODE] = BLANK_CHECK_SECTOR;
00081a  2135              MOVS     r1,#0x35
00081c  3014              ADDS     r0,r0,#0x14
;;;853        param_table[IAP_PARAM_0] = USER_START_SECTOR;
00081e  6001              STR      r1,[r0,#0]  ; param_table
000820  2102              MOVS     r1,#2
;;;854        param_table[IAP_PARAM_1] = USER_START_SECTOR;
000822  6041              STR      r1,[r0,#4]  ; param_table
000824  6081              STR      r1,[r0,#8]  ; param_table
000826  0001              MOVS     r1,r0
000828  4a28              LDR      r2,|L1.2252|
00082a  3114              ADDS     r1,r1,#0x14
00082c  f7fffffe          BL       __ARM_common_call_via_r2
;;;855        iap_entry(param_table,result_table);
;;;856    	if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000830  4823              LDR      r0,|L1.2240|
000832  3028              ADDS     r0,r0,#0x28
000834  6800              LDR      r0,[r0,#0]  ; result_table
000836  2800              CMP      r0,#0
000838  d000              BEQ      |L1.2108|
;;;857    	{
;;;858    	    return (FALSE);
;;;859    	}
;;;860    	else
;;;861    	{
;;;862    	    return (TRUE);
00083a  2001              MOVS     r0,#1
                  |L1.2108|
;;;863    	}
;;;864    }
00083c  bc10              POP      {r4}
00083e  bc08              POP      {r3}
000840  4718              BX       r3
;;;865    
                          ENDP

                  check_isp_entry_pin PROC
;;;866    unsigned check_isp_entry_pin(void)
000842  4829              LDR      r0,|L1.2280|
;;;867    {
;;;868        if( (*(volatile unsigned *)ISP_ENTRY_GPIO_REG) & (0x1<<ISP_ENTRY_PIN) )
000844  6800              LDR      r0,[r0,#0]
000846  0400              LSLS     r0,r0,#16
000848  d501              BPL      |L1.2126|
;;;869    	{
;;;870    	    return(TRUE);
00084a  2001              MOVS     r0,#1
;;;871    	}
;;;872    	else
;;;873    	{
;;;874    	    return(FALSE);
;;;875    	}
;;;876    }
00084c  4770              BX       lr
                  |L1.2126|
00084e  2000              MOVS     r0,#0                 ;874
000850  4770              BX       lr
;;;877    
                          ENDP

                  exec_isp_cmd PROC
;;;878    void exec_isp_cmd(int no_of_param)
000852  b570              PUSH     {r4-r6,lr}
;;;879    {
;;;880        int c;
;;;881    
;;;882        c = *(param_buf[ISP_CMD_CODE]);
000854  4c1a              LDR      r4,|L1.2240|
000856  4a1d              LDR      r2,|L1.2252|
000858  6820              LDR      r0,[r4,#0]  ; param_buf
00085a  7803              LDRB     r3,[r0,#0]
;;;883        if(c != NUL);
;;;884        {
;;;885            switch(c)
;;;886            {
;;;887            /* Write to RAM command */
;;;888            case 'W':
;;;889                write_to_ram();
;;;890                break;
;;;891            /* Read command */
;;;892            case 'R':
;;;893                read();
;;;894                break;
;;;895            /* Go command */
;;;896            case 'G':
;;;897                go_cmd();
;;;898                break;
;;;899            /* Unlock command */
;;;900            case 'U':
;;;901                unlock();
;;;902                break;
;;;903            /* Read Part Identification number command */
;;;904            case 'J':
;;;905                param_table[IAP_CMD_CODE] = READ_PART_ID;
00085c  0020              MOVS     r0,r4
00085e  3014              ADDS     r0,r0,#0x14
000860  0005              MOVS     r5,r0
000862  3b43              SUBS     r3,r3,#0x43           ;885
000864  3514              ADDS     r5,r5,#0x14           ;885
000866  f7fffffe          BL       __ARM_common_switch8
00086a  1565              DCB      0x15,0x65
00086c  71687112          DCB      0x71,0x68,0x71,0x12
000870  716b1841          DCB      0x71,0x6b,0x18,0x41
000874  716e7171          DCB      0x71,0x6e,0x71,0x71
000878  62710f71          DCB      0x62,0x71,0x0f,0x71
00087c  7115710c          DCB      0x71,0x15,0x71,0x0c
000880  7100              DCB      0x71,0x00
000882  f7fffffe          BL       write_to_ram
;;;906                iap_entry(param_table,result_table);
;;;907                sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
;;;908                PARAM_SIZE));
;;;909                sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
;;;910                PARAM_SIZE));
;;;911            break;
;;;912            /* Read Boot Code Version number command */
;;;913            case 'K':
;;;914                param_table[IAP_CMD_CODE] = READ_BOOT_VER;
;;;915                iap_entry(param_table,result_table);
;;;916                sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
;;;917                PARAM_SIZE));
;;;918                sendline_crlf(i_to_a((char)result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
;;;919                PARAM_SIZE));
;;;920                sendline_crlf(i_to_a((char)(result_table[IAP_RESULT_0]>>8),param_buf[ISP_PARAM_1], \
;;;921                PARAM_SIZE));
;;;922                break;
;;;923            /* Prepare sector for write operation command */
;;;924            case 'P':
;;;925                prepare_sector();
;;;926                break;
;;;927            /* Copy RAM to FLASH command */
;;;928            case 'C':
;;;929                copy();
;;;930                break;
;;;931            /* Erase sector command */
;;;932            case 'E':
;;;933                erase();
;;;934                break;
;;;935            /* Blank check sector command */
;;;936            case 'I':
;;;937                blank_check();
;;;938                break;
;;;939            /* Compare Memory */
;;;940            case 'M':
;;;941                compare_mem();
;;;942                break;
;;;943            /* Invalid Command */
;;;944            default:
;;;945                sendline_crlf(i_to_a(INVALID_COMMAND,param_buf[ISP_PARAM_1], \
;;;946                PARAM_SIZE));
;;;947                break;
;;;948            } /* switch(c) */
;;;949        } /* if c != NUL */
;;;950    } /* exec_isp_cmd */
000886  e403              B        |L1.144|
000888  f7fffffe          BL       read
00088c  e65d              B        |L1.1354|
00088e  f7fffffe          BL       go_cmd
000892  e65a              B        |L1.1354|
000894  f7fffffe          BL       unlock
000898  e657              B        |L1.1354|
00089a  2136              MOVS     r1,#0x36              ;905
00089c  6001              STR      r1,[r0,#0]            ;905  ; param_table
00089e  4908              LDR      r1,|L1.2240|
0008a0  3128              ADDS     r1,r1,#0x28           ;905
0008a2  0008              MOVS     r0,r1                 ;905
0008a4  3814              SUBS     r0,r0,#0x14           ;905
0008a6  f7fffffe          BL       __ARM_common_call_via_r2
0008aa  6861              LDR      r1,[r4,#4]            ;907  ; param_buf
0008ac  6828              LDR      r0,[r5,#0]            ;907  ; result_table
0008ae  220f              MOVS     r2,#0xf               ;907
0008b0  f7fffffe          BL       i_to_a
0008b4  f7fffffe          BL       sendline_crlf
0008b8  6861              LDR      r1,[r4,#4]            ;909  ; param_buf
0008ba  6868              LDR      r0,[r5,#4]            ;911  ; result_table
0008bc  e031              B        |L1.2338|
0008be  0000              DCW      0x0000
                  |L1.2240|
                          DCD      ||.bss||+0x94
                  |L1.2244|
                          DCD      0x00005a5a
                  |L1.2248|
                          DCD      ||.data||
                  |L1.2252|
                          DCD      0x7ffffff1
                  |L1.2256|
                          DCD      0x12345678
                  |L1.2260|
                          DCD      fcclk_KHz
                  |L1.2264|
                          DCD      0x87654321
                  |L1.2268|
                          DCD      0x43218765
                  |L1.2272|
                          DCD      0x11223344
                  |L1.2276|
                          DCD      0xfffff000
                  |L1.2280|
                          DCD      0xe0028000
0008ec  2137              MOVS     r1,#0x37              ;914
0008ee  6001              STR      r1,[r0,#0]            ;914  ; param_table
0008f0  494a              LDR      r1,|L1.2588|
0008f2  0008              MOVS     r0,r1                 ;914
0008f4  3814              SUBS     r0,r0,#0x14           ;914
0008f6  f7fffffe          BL       __ARM_common_call_via_r2
0008fa  6861              LDR      r1,[r4,#4]            ;916  ; param_buf
0008fc  6828              LDR      r0,[r5,#0]            ;916  ; result_table
0008fe  220f              MOVS     r2,#0xf               ;916
000900  f7fffffe          BL       i_to_a
000904  f7fffffe          BL       sendline_crlf
000908  6868              LDR      r0,[r5,#4]            ;918  ; result_table
00090a  6861              LDR      r1,[r4,#4]            ;918  ; param_buf
00090c  0600              LSLS     r0,r0,#24             ;918
00090e  0e00              LSRS     r0,r0,#24             ;918
000910  220f              MOVS     r2,#0xf               ;918
000912  f7fffffe          BL       i_to_a
000916  f7fffffe          BL       sendline_crlf
00091a  6868              LDR      r0,[r5,#4]            ;920  ; result_table
00091c  6861              LDR      r1,[r4,#4]            ;920  ; param_buf
00091e  0400              LSLS     r0,r0,#16             ;920
000920  0e00              LSRS     r0,r0,#24             ;920
                  |L1.2338|
000922  220f              MOVS     r2,#0xf               ;909
                  |L1.2340|
000924  f7fffffe          BL       i_to_a
000928  f7fffffe          BL       sendline_crlf
00092c  e60d              B        |L1.1354|
00092e  f7fffffe          BL       prepare_sector
000932  e60a              B        |L1.1354|
000934  f7fffffe          BL       copy
000938  e607              B        |L1.1354|
00093a  f7fffffe          BL       erase
00093e  e604              B        |L1.1354|
000940  f7fffffe          BL       blank_check
000944  e601              B        |L1.1354|
000946  f7fffffe          BL       compare_mem
00094a  e5fe              B        |L1.1354|
00094c  220f              MOVS     r2,#0xf               ;945
00094e  6861              LDR      r1,[r4,#4]            ;947  ; param_buf
000950  2001              MOVS     r0,#1                 ;945
000952  e7e7              B        |L1.2340|
;;;951    
                          ENDP

                  isp_cmd_loop PROC
;;;952    /* only returns if timeout occurred */
;;;953    void isp_cmd_loop(void)
000954  b5fe              PUSH     {r1-r7,lr}
;;;954    {
;;;955        int cmd_len,no_of_param,crp_block_common_cmd,crp_block_crp2_crp3_cmd;
;;;956    	int result;
;;;957        
;;;958    	/* initialize to avoid compiler warning  */
;;;959        /* Lock Flash Write/Erase/Go Commands */
;;;960        lock = TRUE;
000956  4832              LDR      r0,|L1.2592|
000958  2101              MOVS     r1,#1
;;;961        
;;;962        /* intialize parameter buffer */
;;;963        param_buf[ISP_PARAM_0] = param0;
00095a  6001              STR      r1,[r0,#0]  ; lock
00095c  492f              LDR      r1,|L1.2588|
;;;964        param_buf[ISP_PARAM_1] = param1;
;;;965        param_buf[ISP_PARAM_2] = param2;
;;;966        param_buf[ISP_PARAM_3] = param3;
;;;967        param_buf[ISP_PARAM_4] = param4;
;;;968    
;;;969        /* Initialize cp_after_reset variable to allow ISP session to program 
;;;970           code protection enabled user application */
;;;971    	crp_after_reset = crp;
;;;972    
;;;973    	crp_block_crp2_crp3_cmd = TRUE;
;;;974    
;;;975    	while(1)
;;;976        {
;;;977    	    result = getline(cmd_buf,CMD_SIZE,&cmd_len);
;;;978            if(result == 0)
;;;979            {
;;;980                /* To safegaurd against insufficient parameters fill parameter buffers with
;;;981                   Non numeric ascii charcaters */
;;;982                for(no_of_param=0;no_of_param<NO_OF_ISP_PARAMS;no_of_param++)
;;;983                {
;;;984                    *(param_buf[no_of_param]) = 'z';
;;;985                }
;;;986                no_of_param = tokenize(&cmd_buf[0],cmd_len,&param_buf[0],NO_OF_ISP_PARAMS,PARAM_SIZE);  
;;;987                if(no_of_param != 0)
;;;988                {
;;;989                   /* Common ISP commands to be blocked for code read protection Level 1, 2 or 3 */
;;;990                   if( ( (*(param_buf[ISP_CMD_CODE]) == 'R') ||              \
;;;991                         (*(param_buf[ISP_CMD_CODE]) == 'G') ||              \
;;;992                         (*(param_buf[ISP_CMD_CODE]) == 'M') ) )
;;;993                   {
;;;994                      crp_block_common_cmd = TRUE;
;;;995                   }
;;;996                   else
;;;997                   {
;;;998                      crp_block_common_cmd = FALSE;
;;;999                      /* ISP commands to be blocked for code read protection Level 2 and 3 */
;;;1000                     if( ( (*(param_buf[ISP_CMD_CODE]) == 'W') ||              \
;;;1001                           (*(param_buf[ISP_CMD_CODE]) == 'C') ) )
;;;1002                     {
;;;1003                        crp_block_crp2_crp3_cmd = TRUE;
;;;1004                     }
;;;1005                     else
;;;1006                     {
;;;1007                        crp_block_crp2_crp3_cmd = FALSE;
;;;1008                     }
;;;1009                  }
;;;1010   
;;;1011                  if( ( (crp_after_reset == CRP1) ||            \
;;;1012                        (crp_after_reset == CRP2) ||     \
00095e  4e32              LDR      r6,|L1.2600|
000960  3976              SUBS     r1,r1,#0x76           ;963
000962  000d              MOVS     r5,r1                 ;963
000964  354e              ADDS     r5,r5,#0x4e           ;963
000966  6029              STR      r1,[r5,#0]            ;964  ; param_buf
000968  310f              ADDS     r1,r1,#0xf            ;964
00096a  6069              STR      r1,[r5,#4]            ;965  ; param_buf
00096c  310f              ADDS     r1,r1,#0xf            ;965
00096e  60a9              STR      r1,[r5,#8]            ;966  ; param_buf
000970  310f              ADDS     r1,r1,#0xf            ;966
000972  60e9              STR      r1,[r5,#0xc]          ;967  ; param_buf
000974  310f              ADDS     r1,r1,#0xf            ;967
000976  6129              STR      r1,[r5,#0x10]         ;971  ; param_buf
000978  492a              LDR      r1,|L1.2596|
;;;1013                        (crp_after_reset == CRP3) )      \
00097a  4f2c              LDR      r7,|L1.2604|
00097c  6809              LDR      r1,[r1,#0]            ;971  ; crp
00097e  2401              MOVS     r4,#1                 ;973
000980  6041              STR      r1,[r0,#4]  ; crp_after_reset
                  |L1.2434|
000982  4826              LDR      r0,|L1.2588|
000984  2146              MOVS     r1,#0x46              ;977
000986  38bc              SUBS     r0,r0,#0xbc           ;977
000988  aa01              ADD      r2,sp,#4              ;977
00098a  f7fffffe          BL       getline
00098e  2800              CMP      r0,#0                 ;978
000990  d140              BNE      |L1.2580|
000992  217a              MOVS     r1,#0x7a              ;984
                  |L1.2452|
000994  0082              LSLS     r2,r0,#2              ;984
000996  58aa              LDR      r2,[r5,r2]            ;984
000998  1c40              ADDS     r0,r0,#1              ;982
00099a  2805              CMP      r0,#5                 ;982
00099c  7011              STRB     r1,[r2,#0]            ;984
00099e  dbf9              BLT      |L1.2452|
0009a0  220f              MOVS     r2,#0xf               ;986
0009a2  9200              STR      r2,[sp,#0]            ;986
0009a4  4a1d              LDR      r2,|L1.2588|
0009a6  9901              LDR      r1,[sp,#4]            ;986
0009a8  3a28              SUBS     r2,r2,#0x28           ;986
0009aa  0010              MOVS     r0,r2                 ;986
0009ac  3894              SUBS     r0,r0,#0x94           ;986
0009ae  2305              MOVS     r3,#5                 ;986
0009b0  f7fffffe          BL       tokenize
0009b4  2800              CMP      r0,#0                 ;987
0009b6  d0e4              BEQ      |L1.2434|
0009b8  6829              LDR      r1,[r5,#0]            ;990  ; param_buf
0009ba  7809              LDRB     r1,[r1,#0]            ;990
0009bc  2952              CMP      r1,#0x52              ;990
0009be  d003              BEQ      |L1.2504|
0009c0  2947              CMP      r1,#0x47              ;991
0009c2  d001              BEQ      |L1.2504|
0009c4  294d              CMP      r1,#0x4d              ;992
0009c6  d101              BNE      |L1.2508|
                  |L1.2504|
0009c8  2201              MOVS     r2,#1                 ;994
0009ca  e007              B        |L1.2524|
                  |L1.2508|
0009cc  2200              MOVS     r2,#0                 ;998
0009ce  2957              CMP      r1,#0x57              ;1000
0009d0  d001              BEQ      |L1.2518|
0009d2  2943              CMP      r1,#0x43              ;1001
0009d4  d101              BNE      |L1.2522|
                  |L1.2518|
0009d6  2401              MOVS     r4,#1                 ;1003
0009d8  e000              B        |L1.2524|
                  |L1.2522|
0009da  2400              MOVS     r4,#0                 ;1007
                  |L1.2524|
0009dc  4910              LDR      r1,|L1.2592|
0009de  4b14              LDR      r3,|L1.2608|
0009e0  6849              LDR      r1,[r1,#4]            ;1011  ; crp_after_reset
0009e2  4299              CMP      r1,r3                 ;1011
0009e4  d003              BEQ      |L1.2542|
0009e6  42b1              CMP      r1,r6                 ;1012
0009e8  d001              BEQ      |L1.2542|
0009ea  42b9              CMP      r1,r7
0009ec  d109              BNE      |L1.2562|
                  |L1.2542|
;;;1014                                           &&                                 \
;;;1015                       ( crp_block_common_cmd == TRUE )
0009ee  2a01              CMP      r2,#1
0009f0  d107              BNE      |L1.2562|
                  |L1.2546|
;;;1016                     )
;;;1017                   {
;;;1018                       /* Code read protection Level 1, 2 or 3 enabled. Block Read,
;;;1019                          Go and Compare ISP commands */
;;;1020                       sendline_crlf(i_to_a(CODE_READ_PROTECTION_ENABLED, \
0009f2  6869              LDR      r1,[r5,#4]  ; param_buf
0009f4  220f              MOVS     r2,#0xf
0009f6  2013              MOVS     r0,#0x13
0009f8  f7fffffe          BL       i_to_a
0009fc  f7fffffe          BL       sendline_crlf
000a00  e7bf              B        |L1.2434|
                  |L1.2562|
;;;1021                       param_buf[ISP_PARAM_1],PARAM_SIZE));
;;;1022                   }  
;;;1023                   else
;;;1024                   {
;;;1025                      if( ( (crp_after_reset == CRP2) ||            \
000a02  42b1              CMP      r1,r6
000a04  d001              BEQ      |L1.2570|
;;;1026                            (crp_after_reset == CRP3) )  
000a06  42b9              CMP      r1,r7
000a08  d101              BNE      |L1.2574|
                  |L1.2570|
;;;1027                                            &&                                   \
;;;1028                           ( crp_block_crp2_crp3_cmd == TRUE ) )
000a0a  2c01              CMP      r4,#1
000a0c  d0f1              BEQ      |L1.2546|
                  |L1.2574|
;;;1029                      {
;;;1030                       /* Code read protection Level 2 or 3 is enabled. Block Write
;;;1031                          and Copy ISP commands */
;;;1032                          sendline_crlf(i_to_a(CODE_READ_PROTECTION_ENABLED, \
;;;1033                          param_buf[ISP_PARAM_1],PARAM_SIZE));
;;;1034                      }
;;;1035                      else
;;;1036                      {
;;;1037                          exec_isp_cmd(no_of_param);
000a0e  f7fffffe          BL       exec_isp_cmd
000a12  e7b6              B        |L1.2434|
                  |L1.2580|
;;;1038                      }
;;;1039                   }
;;;1040               } /* if(no_of_param != 0) */
;;;1041           } /* if(serial_getline(cmd_buf,CMD_SIZE,&cmd_len) == 0) */
;;;1042   		else
;;;1043   		{
;;;1044   		  /* timeout */
;;;1045   		  return;
;;;1046   		}
;;;1047   	} /* While(1) loop */
;;;1048   } /* isp_cmd_loop */
000a14  bcfe              POP      {r1-r7}
000a16  bc08              POP      {r3}
000a18  4718              BX       r3
                          ENDP

000a1a  0000              DCW      0x0000
                  |L1.2588|
                          DCD      ||.bss||+0xbc
                  |L1.2592|
                          DCD      ||.data||
                  |L1.2596|
                          DCD      ||crp||
                  |L1.2600|
                          DCD      0x87654321
                  |L1.2604|
                          DCD      0x43218765
                  |L1.2608|
                          DCD      0x12345678

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  cmd_buf
                          %        70
                  param0
                          %        15
                  param1
                          %        15
                  param2
                          %        15
                  param3
                          %        15
                  param4
                          %        18
                  param_buf
                          %        20
                  param_table
                          %        20
                  result_table
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  unlock_code
                          DCD      0x00005a5a

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.6||, ||.constdata||
                  ||ok||
000000  4f4b00            DCB      0x4f,0x4b,0x00
                  resend
000003  52                DCB      0x52
000004  4553454e          DCB      0x45,0x53,0x45,0x4e
000008  4400              DCB      0x44,0x00
                  sync_str
00000a  5379              DCB      0x53,0x79
00000c  6e636872          DCB      0x6e,0x63,0x68,0x72
000010  6f6e697a          DCB      0x6f,0x6e,0x69,0x7a
000014  656400            DCB      0x65,0x64,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  lock
                          DCD      0x00000000
                  crp_after_reset
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=2

                          ARM
                  __ARM_common_switch8 PROC
000000  e55ec001          LDRB     r12,[lr,#-1]
000004  e153000c          CMP      r3,r12
000008  37de3003          LDRBCC   r3,[lr,r3]
00000c  27de300c          LDRBCS   r3,[lr,r12]
000010  e08ec083          ADD      r12,lr,r3,LSL #1
000014  e12fff1c          BX       r12
                          ENDP


                          AREA ||i.__ARM_common_call_via_r2||, COMGROUP=__ARM_common_call_via_r2, CODE, READONLY, ALIGN=1

                          THUMB
                  __ARM_common_call_via_r2 PROC
000000  4710              BX       r2
                          ENDP


                          AREA ||i.__ARM_common_call_via_r0||, COMGROUP=__ARM_common_call_via_r0, CODE, READONLY, ALIGN=1

                  __ARM_common_call_via_r0 PROC
000000  4700              BX       r0
                          ENDP

