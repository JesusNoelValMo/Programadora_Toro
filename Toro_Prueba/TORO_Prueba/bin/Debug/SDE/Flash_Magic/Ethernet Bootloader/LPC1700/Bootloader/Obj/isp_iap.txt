; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\isp_iap.o --depend=.\Obj\isp_iap.d --device=DARMP1 --apcs=interwork -O3 -I. -I.\Core_CM3 -ID:\Keil\ARM\INC\NXP --omf_browse=.\Obj\isp_iap.crf isp\isp_iap.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  is_div PROC
;;;34     
;;;35     int is_div(unsigned value,unsigned div)
000000  1e49              SUBS     r1,r1,#1
;;;36     {
;;;37         if(value & (div -1))
000002  4008              ANDS     r0,r0,r1
000004  d000              BEQ      |L1.8|
;;;38         {
;;;39             return(1);
000006  2001              MOVS     r0,#1
                  |L1.8|
;;;40         }
;;;41         else
;;;42         {
;;;43             return(0);
;;;44         }
;;;45     }/* is_div */
000008  4770              BX       lr
;;;46     
                          ENDP

                  __rt_div0 PROC
;;;47     void __rt_div0(void)
00000a  4770              BX       lr
;;;48     {
;;;49     } /* __rt_div0 */
;;;50     
                          ENDP

                  str_cmp PROC
;;;51     int str_cmp(char * src, char * dst)
00000c  b510              PUSH     {r4,lr}
;;;52     {
;;;53         int i = 0;
00000e  2200              MOVS     r2,#0
;;;54         
;;;55         for(i=0;src[i] == dst[i];i++)
000010  e003              B        |L1.26|
                  |L1.18|
;;;56         {
;;;57             if(src[i] == NUL)
000012  b90b              CBNZ     r3,|L1.24|
;;;58             {
;;;59                 return(NUL);
000014  2000              MOVS     r0,#0
;;;60             }
;;;61         }
;;;62         return(src[i]-dst[i]);
;;;63     } /* str_cmp */
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  1c52              ADDS     r2,r2,#1              ;55
                  |L1.26|
00001a  5c83              LDRB     r3,[r0,r2]            ;55
00001c  5c8c              LDRB     r4,[r1,r2]            ;55
00001e  42a3              CMP      r3,r4                 ;55
000020  d0f7              BEQ      |L1.18|
000022  5c80              LDRB     r0,[r0,r2]            ;62
000024  5c89              LDRB     r1,[r1,r2]            ;62
000026  1a40              SUBS     r0,r0,r1              ;62
000028  bd10              POP      {r4,pc}
;;;64     
                          ENDP

                  a_to_i PROC
;;;65     int a_to_i(char * inbuf,unsigned * outint)
00002a  b570              PUSH     {r4-r6,lr}
;;;66     {
;;;67         unsigned int value=0,i;
00002c  2400              MOVS     r4,#0
;;;68         
;;;69         for(i=0;inbuf[i] != 0;i++)
00002e  4622              MOV      r2,r4
;;;70         {
;;;71             if(inbuf[i] >= '0' && inbuf[i] <= '9')
;;;72             {
;;;73                 value = 10 * value +(inbuf[i] - '0');
000030  f06f052f          MVN      r5,#0x2f
000034  e00a              B        |L1.76|
000036  bf00              NOP                            ;71
                  |L1.56|
000038  f1a30630          SUB      r6,r3,#0x30           ;71
00003c  2e09              CMP      r6,#9                 ;71
00003e  d80b              BHI      |L1.88|
000040  eb040484          ADD      r4,r4,r4,LSL #2
000044  eb050444          ADD      r4,r5,r4,LSL #1
000048  441c              ADD      r4,r4,r3
00004a  1c52              ADDS     r2,r2,#1              ;69
                  |L1.76|
00004c  5c83              LDRB     r3,[r0,r2]            ;69
00004e  2b00              CMP      r3,#0                 ;69
000050  d1f2              BNE      |L1.56|
;;;74             }
;;;75             else
;;;76             {
;;;77                 return(1);
;;;78             }
;;;79         }
;;;80         *outint = value;
;;;81         return(0);
000052  2000              MOVS     r0,#0
000054  600c              STR      r4,[r1,#0]
;;;82     } /* a_to_i */
000056  bd70              POP      {r4-r6,pc}
                  |L1.88|
000058  2001              MOVS     r0,#1                 ;77
00005a  bd70              POP      {r4-r6,pc}
;;;83     
                          ENDP

                  i_to_a PROC
;;;84     
;;;85     char * i_to_a(unsigned i_num, char * str, unsigned str_len)
00005c  b510              PUSH     {r4,lr}
;;;86     {
;;;87         char remainder;
;;;88     
;;;89         str[--str_len] = NUL;
00005e  2300              MOVS     r3,#0
000060  1e52              SUBS     r2,r2,#1
000062  548b              STRB     r3,[r1,r2]
;;;90     
;;;91         if(i_num == 0)
;;;92         {
;;;93             str[--str_len] = '0';
;;;94             return(str + str_len);
;;;95         }
;;;96     
;;;97         while (((str_len>0) && (i_num!=0)))
;;;98         {
;;;99             str_len--;
;;;100            remainder = (char) (i_num % 10);
000064  240a              MOVS     r4,#0xa
000066  b978              CBNZ     r0,|L1.136|
000068  2030              MOVS     r0,#0x30              ;93
00006a  1e52              SUBS     r2,r2,#1              ;93
00006c  5488              STRB     r0,[r1,r2]            ;93
00006e  e00e              B        |L1.142|
                  |L1.112|
000070  fbb0f3f4          UDIV     r3,r0,r4
000074  fb040013          MLS      r0,r4,r3,r0
000078  1e52              SUBS     r2,r2,#1              ;99
;;;101            if ( remainder <= 9 )
00007a  2809              CMP      r0,#9
00007c  d801              BHI      |L1.130|
;;;102            {
;;;103                str[str_len] = remainder + '0';
00007e  3030              ADDS     r0,r0,#0x30
000080  e000              B        |L1.132|
                  |L1.130|
;;;104            }
;;;105            else  
;;;106            {
;;;107                str[str_len] = remainder - 10 + 'A';
000082  3037              ADDS     r0,r0,#0x37
                  |L1.132|
000084  5488              STRB     r0,[r1,r2]
000086  4618              MOV      r0,r3
                  |L1.136|
000088  b10a              CBZ      r2,|L1.142|
00008a  2800              CMP      r0,#0                 ;97
00008c  d1f0              BNE      |L1.112|
                  |L1.142|
;;;108            }
;;;109            i_num = i_num/10;
;;;110        }
;;;111        return (str + str_len);
00008e  1888              ADDS     r0,r1,r2
;;;112    } /* i_to_a */
000090  bd10              POP      {r4,pc}
;;;113    
                          ENDP

                  run_isp PROC
;;;114    const char sync_str[] = "Synchronized";
;;;115    void run_isp(void)
000092  b508              PUSH     {r3,lr}
;;;116    {
;;;117        int count;
;;;118    
;;;119        /* wait for host to initiate communication */
;;;120    	getline(cmd_buf,CMD_SIZE,&count);
000094  466a              MOV      r2,sp
000096  2146              MOVS     r1,#0x46
000098  48ff              LDR      r0,|L1.1176|
00009a  f7fffffe          BL       getline
;;;121    
;;;122    	/* send "Synchronized" string response */
;;;123    	sendline_crlf((char *)sync_str);
00009e  48ff              LDR      r0,|L1.1180|
0000a0  f7fffffe          BL       sendline_crlf
;;;124    
;;;125        /* wait for host to respond */
;;;126    	getline(cmd_buf,CMD_SIZE,&count);
0000a4  466a              MOV      r2,sp
0000a6  2146              MOVS     r1,#0x46
0000a8  48fb              LDR      r0,|L1.1176|
0000aa  f7fffffe          BL       getline
;;;127    
;;;128    	/* Compare HOST response with the original string */
;;;129    	if(str_cmp(cmd_buf,(char *)sync_str) == 0)
0000ae  49fb              LDR      r1,|L1.1180|
0000b0  48f9              LDR      r0,|L1.1176|
0000b2  f7fffffe          BL       str_cmp
;;;130    	{
;;;131    		/* Autobaud is successful. Get out of while loop. */
;;;132    	}
;;;133    	else
;;;134    	{
;;;135    	}
;;;136    }
0000b6  bd08              POP      {r3,pc}
;;;137    
                          ENDP

                  param_check PROC
;;;138    unsigned param_check(char * param_str,unsigned * param_ptr,int param_type,int count)
0000b8  b5f0              PUSH     {r4-r7,lr}
;;;139    {
0000ba  460f              MOV      r7,r1
0000bc  4615              MOV      r5,r2
0000be  461e              MOV      r6,r3
;;;140        int rc,return_code,in_flash,in_ram;
;;;141        return_code = 0;
0000c0  2400              MOVS     r4,#0
;;;142        /* check if conversion from str to integer is required */
;;;143        if(param_str != NUL)
0000c2  b128              CBZ      r0,|L1.208|
;;;144        {
;;;145            rc = a_to_i(param_str,param_ptr);
0000c4  4639              MOV      r1,r7
0000c6  f7fffffe          BL       a_to_i
;;;146            if(rc != 0)
0000ca  b108              CBZ      r0,|L1.208|
;;;147            {
;;;148                return(PARAM_ERROR);
0000cc  200c              MOVS     r0,#0xc
;;;149            }
;;;150        }
;;;151    
;;;152        if(param_type == NO_PARAM_CHECK)
;;;153        {
;;;154            /* further testing is not required. Verification is done in  
;;;155               related commands */
;;;156            return(0);
;;;157        }
;;;158        
;;;159        rc = is_div(*param_ptr,BY_4);
;;;160        if( rc != 0)
;;;161        {   
;;;162            if(param_type == COUNT)
;;;163            {
;;;164                return_code = COUNT_ERROR;
;;;165            }
;;;166            else
;;;167            {
;;;168                return_code = ADDR_ERROR;
;;;169                /* Now distinguish between SRC & DST if required */
;;;170                if(param_type == RAM_ADDRESS)
;;;171                {
;;;172                    return_code = SRC_ADDR_ERROR;
;;;173                }
;;;174                if(param_type == FLASH_ADDRESS)
;;;175                {
;;;176                    return_code = DST_ADDR_ERROR;
;;;177                }
;;;178            } /* Address error */
;;;179        } /* is_div by 4 error */
;;;180    
;;;181        /* Check for address mapping if required. Each type of address requires a 
;;;182        different type of test. Do this testing only if previous test is ok */
;;;183        if(return_code == 0)
;;;184        {
;;;185            if( ((*param_ptr >= RAM_START) && ((*param_ptr+count) <= (RAM_END+1))) )
;;;186            {
;;;187                in_ram = TRUE;
;;;188            }
;;;189            else
;;;190            {
;;;191                in_ram = FALSE;
;;;192            }
;;;193            if( ((*param_ptr >= USER_START_SECTOR_ADDRESS) && ((*param_ptr+count) <= (USER_END_SECTOR_ADDRESS+1))) )
;;;194            {
;;;195                in_flash = TRUE;
;;;196            }
;;;197            else
;;;198            {
;;;199                in_flash = FALSE;
;;;200            }
;;;201            if(param_type == RAM_OR_FLASH_ADDRESS)
;;;202            {
;;;203                if( !(in_ram || in_flash) )
;;;204                {
;;;205                    return_code = ADDR_NOT_MAPPED;
;;;206                }
;;;207            }
;;;208            if(param_type == RAM_ADDRESS)
;;;209            {
;;;210                if( !(in_ram) )
;;;211                {
;;;212                    return_code = SRC_ADDR_NOT_MAPPED;
;;;213                }
;;;214            }
;;;215        }
;;;216        return(return_code);
;;;217    }/* param_check */
0000ce  bdf0              POP      {r4-r7,pc}
                  |L1.208|
0000d0  2d69              CMP      r5,#0x69              ;152
0000d2  d101              BNE      |L1.216|
0000d4  2000              MOVS     r0,#0                 ;156
0000d6  bdf0              POP      {r4-r7,pc}
                  |L1.216|
0000d8  2104              MOVS     r1,#4                 ;159
0000da  6838              LDR      r0,[r7,#0]            ;159
0000dc  f7fffffe          BL       is_div
0000e0  b168              CBZ      r0,|L1.254|
0000e2  2d64              CMP      r5,#0x64              ;162
0000e4  d101              BNE      |L1.234|
0000e6  2406              MOVS     r4,#6                 ;164
0000e8  e028              B        |L1.316|
                  |L1.234|
0000ea  240d              MOVS     r4,#0xd               ;168
0000ec  2d67              CMP      r5,#0x67              ;170
0000ee  d101              BNE      |L1.244|
0000f0  2402              MOVS     r4,#2                 ;172
0000f2  e023              B        |L1.316|
                  |L1.244|
0000f4  2d68              CMP      r5,#0x68              ;174
0000f6  d101              BNE      |L1.252|
0000f8  2403              MOVS     r4,#3                 ;176
0000fa  e01f              B        |L1.316|
                  |L1.252|
0000fc  b9f4              CBNZ     r4,|L1.316|
                  |L1.254|
0000fe  6839              LDR      r1,[r7,#0]            ;185
000100  f1b15f80          CMP      r1,#0x10000000        ;185
000104  d305              BCC      |L1.274|
000106  4ae6              LDR      r2,|L1.1184|
000108  1988              ADDS     r0,r1,r6              ;185
00010a  4290              CMP      r0,r2                 ;185
00010c  d801              BHI      |L1.274|
00010e  2001              MOVS     r0,#1                 ;187
000110  e000              B        |L1.276|
                  |L1.274|
000112  2000              MOVS     r0,#0                 ;191
                  |L1.276|
000114  f5b15f00          CMP      r1,#0x2000            ;193
000118  d305              BCC      |L1.294|
00011a  4431              ADD      r1,r1,r6              ;193
00011c  f5b12f00          CMP      r1,#0x80000           ;193
000120  d801              BHI      |L1.294|
000122  2101              MOVS     r1,#1                 ;195
000124  e000              B        |L1.296|
                  |L1.294|
000126  2100              MOVS     r1,#0                 ;199
                  |L1.296|
000128  2d66              CMP      r5,#0x66              ;201
00012a  d103              BNE      |L1.308|
00012c  4308              ORRS     r0,r0,r1              ;203
00012e  d105              BNE      |L1.316|
000130  240e              MOVS     r4,#0xe               ;205
000132  e003              B        |L1.316|
                  |L1.308|
000134  2d67              CMP      r5,#0x67              ;208
000136  d101              BNE      |L1.316|
000138  b900              CBNZ     r0,|L1.316|
00013a  2404              MOVS     r4,#4                 ;212
                  |L1.316|
00013c  4620              MOV      r0,r4                 ;216
00013e  bdf0              POP      {r4-r7,pc}
;;;218    
                          ENDP

                  iap_entry PROC
;;;219    void iap_entry(unsigned param_tab[],unsigned result_tab[])
000140  4ad8              LDR      r2,|L1.1188|
;;;220    {
;;;221        void (*iap)(unsigned [],unsigned []);
;;;222    
;;;223        iap = (void (*)(unsigned [],unsigned []))IAP_ADDRESS;
;;;224        iap(param_tab,result_tab);
000142  4710              BX       r2
;;;225    }
;;;226    
                          ENDP

                  decode PROC
;;;227    char decode(char c)
000144  2860              CMP      r0,#0x60
;;;228    {
;;;229        if(c == 0x60)
000146  d101              BNE      |L1.332|
;;;230        {
;;;231            return(0x00);
000148  2000              MOVS     r0,#0
;;;232        }
;;;233        else
;;;234        {
;;;235            return(c - SP);
;;;236        }
;;;237    }
00014a  4770              BX       lr
                  |L1.332|
00014c  3820              SUBS     r0,r0,#0x20           ;235
00014e  b2c0              UXTB     r0,r0                 ;235
000150  4770              BX       lr
;;;238    
                          ENDP

                  uudecode PROC
;;;239    unsigned uudecode(char * inbuf, char * outbuf, int * count)
000152  b5f0              PUSH     {r4-r7,lr}
;;;240    {
000154  4603              MOV      r3,r0
;;;241        unsigned sum;
;;;242        int in_byte_count,out_byte_count;
;;;243        
;;;244        sum=0;
000156  2600              MOVS     r6,#0
;;;245        out_byte_count=0;
000158  4635              MOV      r5,r6
;;;246        in_byte_count = decode(*inbuf);
00015a  7800              LDRB     r0,[r0,#0]
00015c  f7fffffe          BL       decode
000160  4604              MOV      r4,r0
;;;247        /* Do not decode if byte count is > 45 */
;;;248        if( (in_byte_count > 0) && (in_byte_count <= UU_LINE) )
000162  1e40              SUBS     r0,r0,#1
000164  282c              CMP      r0,#0x2c
000166  d84c              BHI      |L1.514|
;;;249        {
;;;250            for (++inbuf; in_byte_count > 0; inbuf += 4, in_byte_count -= 3)
000168  1c5b              ADDS     r3,r3,#1
00016a  e048              B        |L1.510|
                  |L1.364|
;;;251            {
;;;252                /* !!! Test for valid printable character is not done !!! */
;;;253                if(in_byte_count >= 3)
00016c  2c03              CMP      r4,#3
00016e  db26              BLT      |L1.446|
;;;254                {
;;;255                    outbuf[0] = (decode(inbuf[0]) << 2) | (decode(inbuf[1]) >> 4);
000170  7818              LDRB     r0,[r3,#0]
000172  f7fffffe          BL       decode
000176  0087              LSLS     r7,r0,#2
000178  7858              LDRB     r0,[r3,#1]
00017a  f7fffffe          BL       decode
00017e  ea471010          ORR      r0,r7,r0,LSR #4
000182  7008              STRB     r0,[r1,#0]
;;;256                    outbuf[1] = (decode(inbuf[1]) << 4) | (decode(inbuf[2]) >> 2);
000184  7858              LDRB     r0,[r3,#1]
000186  f7fffffe          BL       decode
00018a  0107              LSLS     r7,r0,#4
00018c  7898              LDRB     r0,[r3,#2]
00018e  f7fffffe          BL       decode
000192  ea470090          ORR      r0,r7,r0,LSR #2
000196  7048              STRB     r0,[r1,#1]
;;;257                    outbuf[2] = (decode(inbuf[2]) << 6) | (decode(inbuf[3]));
000198  78d8              LDRB     r0,[r3,#3]
00019a  f7fffffe          BL       decode
00019e  4607              MOV      r7,r0
0001a0  7898              LDRB     r0,[r3,#2]
0001a2  f7fffffe          BL       decode
0001a6  ea471080          ORR      r0,r7,r0,LSL #6
0001aa  7088              STRB     r0,[r1,#2]
;;;258                    out_byte_count += 3;
;;;259                    sum = sum + outbuf[0] + outbuf[1] + outbuf[2];
0001ac  7808              LDRB     r0,[r1,#0]
0001ae  784f              LDRB     r7,[r1,#1]
0001b0  1ced              ADDS     r5,r5,#3              ;258
0001b2  4438              ADD      r0,r0,r7
0001b4  788f              LDRB     r7,[r1,#2]
;;;260                    outbuf+=3;
0001b6  1cc9              ADDS     r1,r1,#3
0001b8  443e              ADD      r6,r6,r7              ;259
0001ba  4406              ADD      r6,r6,r0              ;259
0001bc  e01d              B        |L1.506|
                  |L1.446|
;;;261                }
;;;262                else
;;;263                {
;;;264                     if(in_byte_count >= 1)
0001be  2c01              CMP      r4,#1
0001c0  db0c              BLT      |L1.476|
;;;265                    {
;;;266                        outbuf[0] = (decode(inbuf[0]) << 2) | (decode(inbuf[1]) >> 4);
0001c2  7818              LDRB     r0,[r3,#0]
0001c4  f7fffffe          BL       decode
0001c8  0087              LSLS     r7,r0,#2
0001ca  7858              LDRB     r0,[r3,#1]
0001cc  f7fffffe          BL       decode
0001d0  ea471010          ORR      r0,r7,r0,LSR #4
0001d4  7008              STRB     r0,[r1,#0]
;;;267                        out_byte_count++;
;;;268                        sum = sum + outbuf[0];
0001d6  b2c0              UXTB     r0,r0
0001d8  1c6d              ADDS     r5,r5,#1              ;267
0001da  4406              ADD      r6,r6,r0
                  |L1.476|
;;;269                      /* No need to increment the outbuf as this is the last for loop iteration */
;;;270                    }
;;;271                    if(in_byte_count >= 2)
0001dc  2c02              CMP      r4,#2
0001de  db0c              BLT      |L1.506|
;;;272                    {
;;;273                        outbuf[1] = (decode(inbuf[1]) << 4) | (decode(inbuf[2]) >> 2);
0001e0  7858              LDRB     r0,[r3,#1]
0001e2  f7fffffe          BL       decode
0001e6  0107              LSLS     r7,r0,#4
0001e8  7898              LDRB     r0,[r3,#2]
0001ea  f7fffffe          BL       decode
0001ee  ea470090          ORR      r0,r7,r0,LSR #2
0001f2  7048              STRB     r0,[r1,#1]
;;;274                        out_byte_count++;
;;;275                        sum = sum + outbuf[1];
0001f4  b2c0              UXTB     r0,r0
0001f6  1c6d              ADDS     r5,r5,#1              ;274
0001f8  4406              ADD      r6,r6,r0
                  |L1.506|
0001fa  1d1b              ADDS     r3,r3,#4              ;250
0001fc  1ee4              SUBS     r4,r4,#3              ;250
                  |L1.510|
0001fe  2c00              CMP      r4,#0                 ;250
000200  dcb4              BGT      |L1.364|
                  |L1.514|
;;;276                      /* No need to increment the outbuf as this is the last for loop iteration */
;;;277                    }
;;;278                }
;;;279            } /* for loop */
;;;280        }
;;;281        *count = out_byte_count;
;;;282        return(sum);
000202  4630              MOV      r0,r6
000204  6015              STR      r5,[r2,#0]
;;;283    } /* uudecode */
000206  bdf0              POP      {r4-r7,pc}
;;;284    
                          ENDP

                  encode PROC
;;;285    char encode(char c)
000208  b908              CBNZ     r0,|L1.526|
;;;286    {
;;;287        if( c == 0x00)
;;;288        {
;;;289            return(0x60);
00020a  2060              MOVS     r0,#0x60
;;;290        }
;;;291        else
;;;292        {
;;;293            return(c+SP);
;;;294        }
;;;295    }
00020c  4770              BX       lr
                  |L1.526|
00020e  3020              ADDS     r0,r0,#0x20           ;293
000210  b2c0              UXTB     r0,r0                 ;293
000212  4770              BX       lr
;;;296    
                          ENDP

                  uuencode PROC
;;;297    unsigned uuencode(char * inbuf, char * outbuf, int count)
000214  b570              PUSH     {r4-r6,lr}
;;;298    {
000216  4603              MOV      r3,r0
;;;299        unsigned sum;
;;;300        char byte1,byte2;
;;;301        sum = 0;
000218  2400              MOVS     r4,#0
;;;302        *outbuf = encode(count);
00021a  b2d0              UXTB     r0,r2
00021c  f7fffffe          BL       encode
000220  f8010b01          STRB     r0,[r1],#1
;;;303        outbuf++;
;;;304        while(count>0)
000224  e02d              B        |L1.642|
                  |L1.550|
;;;305        {
;;;306            if(count >= 3)
000226  2a03              CMP      r2,#3
000228  db04              BLT      |L1.564|
;;;307            {
;;;308                byte1 = inbuf[1];
;;;309                byte2 = inbuf[2];
00022a  789e              LDRB     r6,[r3,#2]
00022c  785d              LDRB     r5,[r3,#1]            ;308
;;;310                sum = sum + inbuf[0] + inbuf[1] + inbuf[2];
00022e  7818              LDRB     r0,[r3,#0]
000230  4434              ADD      r4,r4,r6
000232  e004              B        |L1.574|
                  |L1.564|
;;;311            }
;;;312            else
;;;313            {
;;;314                if(count == 2)
000234  2a02              CMP      r2,#2
000236  d105              BNE      |L1.580|
;;;315                {
;;;316                    byte1 = inbuf[1];
000238  785d              LDRB     r5,[r3,#1]
;;;317                    byte2 = inbuf[1];
;;;318                    sum = sum + inbuf[0] + inbuf[1];
00023a  7818              LDRB     r0,[r3,#0]
00023c  462e              MOV      r6,r5                 ;317
                  |L1.574|
00023e  4428              ADD      r0,r0,r5
000240  4404              ADD      r4,r4,r0
000242  e002              B        |L1.586|
                  |L1.580|
;;;319                }
;;;320                else
;;;321                {
;;;322                    byte1 = inbuf[0];
000244  781d              LDRB     r5,[r3,#0]
;;;323                    byte2 = inbuf[0];
000246  462e              MOV      r6,r5
;;;324                    sum = sum + inbuf[0];
000248  442c              ADD      r4,r4,r5
                  |L1.586|
;;;325                }
;;;326            }
;;;327            outbuf[0] = encode(((inbuf[0] >> 2) & 0x3F));
00024a  7818              LDRB     r0,[r3,#0]
00024c  0880              LSRS     r0,r0,#2
00024e  f7fffffe          BL       encode
000252  7008              STRB     r0,[r1,#0]
;;;328            outbuf[1] = encode(((inbuf[0] & 0x03) << 4) + ((byte1 & 0xF0) >> 4));
000254  7818              LDRB     r0,[r3,#0]
000256  0780              LSLS     r0,r0,#30
000258  0e80              LSRS     r0,r0,#26
00025a  eb001015          ADD      r0,r0,r5,LSR #4
00025e  f7fffffe          BL       encode
000262  7048              STRB     r0,[r1,#1]
;;;329            outbuf[2] = encode(((byte1 & 0x0F) << 2) + ((byte2 & 0xC0) >> 6));
000264  0728              LSLS     r0,r5,#28
000266  0e80              LSRS     r0,r0,#26
000268  eb001096          ADD      r0,r0,r6,LSR #6
00026c  f7fffffe          BL       encode
000270  7088              STRB     r0,[r1,#2]
;;;330            outbuf[3] = encode((byte2 & 0x3F));
000272  f006003f          AND      r0,r6,#0x3f
000276  f7fffffe          BL       encode
00027a  70c8              STRB     r0,[r1,#3]
;;;331            outbuf+=4;
00027c  1d09              ADDS     r1,r1,#4
;;;332            inbuf+=3;
00027e  1cdb              ADDS     r3,r3,#3
;;;333            count-=3;
000280  1ed2              SUBS     r2,r2,#3
                  |L1.642|
000282  2a00              CMP      r2,#0                 ;304
000284  dccf              BGT      |L1.550|
;;;334        } /* while loop */
;;;335        outbuf[0] = NUL;
000286  2000              MOVS     r0,#0
000288  7008              STRB     r0,[r1,#0]
;;;336        return(sum);
00028a  4620              MOV      r0,r4
;;;337    } /* uuencode */
00028c  bd70              POP      {r4-r6,pc}
;;;338    
                          ENDP

                  write_to_ram PROC
;;;342    
;;;343    void write_to_ram(void)
00028e  b5f0              PUSH     {r4-r7,lr}
;;;344    {
;;;345        unsigned dst,checksum,recvd_checksum;
;;;346        unsigned line_ctr,last_dst;
;;;347        int count,decode_count,last_cnt,char_cnt;
;;;348        unsigned rc;
;;;349        
;;;350        /* Check count validity first as mapping check requires count */
;;;351        rc = param_check(param_buf[ISP_PARAM_2],(unsigned *)&count,COUNT,count);
000290  4d81              LDR      r5,|L1.1176|
000292  b085              SUB      sp,sp,#0x14           ;344
000294  3594              ADDS     r5,r5,#0x94
000296  68a8              LDR      r0,[r5,#8]  ; param_buf
000298  2264              MOVS     r2,#0x64
00029a  a902              ADD      r1,sp,#8
00029c  9b02              LDR      r3,[sp,#8]
00029e  f7fffffe          BL       param_check
0002a2  0004              MOVS     r4,r0
;;;352        if(rc == 0)
0002a4  d10d              BNE      |L1.706|
;;;353        {
;;;354            rc = param_check(param_buf[ISP_PARAM_1],&dst,RAM_ADDRESS,count);
0002a6  6868              LDR      r0,[r5,#4]  ; param_buf
0002a8  2267              MOVS     r2,#0x67
0002aa  a904              ADD      r1,sp,#0x10
0002ac  9b02              LDR      r3,[sp,#8]
0002ae  f7fffffe          BL       param_check
0002b2  4604              MOV      r4,r0
;;;355            if (rc == SRC_ADDR_NOT_MAPPED)
0002b4  2804              CMP      r0,#4
0002b6  d101              BNE      |L1.700|
;;;356            {
;;;357                rc = ADDR_NOT_MAPPED;
0002b8  240e              MOVS     r4,#0xe
0002ba  e002              B        |L1.706|
                  |L1.700|
;;;358            }
;;;359            if (rc == SRC_ADDR_ERROR)
0002bc  2c02              CMP      r4,#2
0002be  d100              BNE      |L1.706|
;;;360            {
;;;361                rc = ADDR_ERROR;
0002c0  240d              MOVS     r4,#0xd
                  |L1.706|
;;;362            }
;;;363        }
;;;364        /* Do not allow write to ISP RAM variable area */
;;;365        if( (crp_after_reset == CRP1) )
0002c2  4879              LDR      r0,|L1.1192|
0002c4  4979              LDR      r1,|L1.1196|
0002c6  6840              LDR      r0,[r0,#4]  ; crp_after_reset
0002c8  4288              CMP      r0,r1
0002ca  d104              BNE      |L1.726|
;;;366        {
;;;367             if( ( dst < (RAM_START) ) )
0002cc  9804              LDR      r0,[sp,#0x10]
0002ce  f1b05f80          CMP      r0,#0x10000000
0002d2  d200              BCS      |L1.726|
;;;368             {
;;;369                 rc = CODE_READ_PROTECTION_ENABLED;
0002d4  2413              MOVS     r4,#0x13
                  |L1.726|
;;;370             }
;;;371         }
;;;372     
;;;373        /* Print command result on serial channel */
;;;374        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_0],PARAM_SIZE));
0002d6  220f              MOVS     r2,#0xf
0002d8  4620              MOV      r0,r4
0002da  6829              LDR      r1,[r5,#0]  ; param_buf
0002dc  f7fffffe          BL       i_to_a
0002e0  f7fffffe          BL       sendline_crlf
;;;375    
;;;376        /* execute command only if parameters are ok */
;;;377        if(rc != CMD_SUCCESS)
0002e4  2c00              CMP      r4,#0
0002e6  d141              BNE      |L1.876|
;;;378        {
;;;379            return;
;;;380        }
;;;381        
;;;382        /* Initialize checksum related variables */
;;;383        checksum = 0;
;;;384        line_ctr = 0;
0002e8  4625              MOV      r5,r4
;;;385        last_dst = dst;
;;;386        last_cnt = count;
;;;387        while(count>0)
0002ea  9f02              LDR      r7,[sp,#8]
0002ec  9e04              LDR      r6,[sp,#0x10]
0002ee  e03a              B        |L1.870|
                  |L1.752|
;;;388        {
;;;389            if(getline(cmd_buf,CMD_SIZE,&char_cnt) != CMD_SUCCESS)
0002f0  466a              MOV      r2,sp
0002f2  2146              MOVS     r1,#0x46
0002f4  4868              LDR      r0,|L1.1176|
0002f6  f7fffffe          BL       getline
0002fa  2800              CMP      r0,#0
0002fc  d136              BNE      |L1.876|
;;;390            {
;;;391                /* Abort command */
;;;392                break;
;;;393            }
;;;394            /* Keep track of number of lines decoded. Need to verify checksum
;;;395               once the LINE_CHECKSUM lines are receieved */
;;;396            if(char_cnt != 0) /* Ignore empty lines */
0002fe  9800              LDR      r0,[sp,#0]
000300  b168              CBZ      r0,|L1.798|
;;;397            {
;;;398                line_ctr++;
000302  1c6d              ADDS     r5,r5,#1
;;;399                checksum = checksum + uudecode(cmd_buf,(char *)dst,&decode_count);
000304  aa01              ADD      r2,sp,#4
000306  4864              LDR      r0,|L1.1176|
000308  9904              LDR      r1,[sp,#0x10]
00030a  f7fffffe          BL       uudecode
00030e  4404              ADD      r4,r4,r0
;;;400                dst = dst + decode_count;
000310  9904              LDR      r1,[sp,#0x10]
000312  9801              LDR      r0,[sp,#4]
000314  4401              ADD      r1,r1,r0
;;;401                count = count - decode_count;
000316  9104              STR      r1,[sp,#0x10]
000318  9902              LDR      r1,[sp,#8]
00031a  1a08              SUBS     r0,r1,r0
00031c  9002              STR      r0,[sp,#8]
                  |L1.798|
;;;402            }
;;;403            /* Need checksum handshake ? */
;;;404            if( ((line_ctr == LINE_CHECKSUM) || (count == 0)) )
00031e  2d14              CMP      r5,#0x14
000320  d001              BEQ      |L1.806|
000322  9802              LDR      r0,[sp,#8]
000324  b9f8              CBNZ     r0,|L1.870|
                  |L1.806|
;;;405            {
;;;406                char_cnt = 0;
000326  2000              MOVS     r0,#0
000328  9000              STR      r0,[sp,#0]
                  |L1.810|
;;;407                /* Get checksum string (ASCII decimal) from host */
;;;408                while(char_cnt == 0)
;;;409                {
;;;410                    rc = getline(cmd_buf,CMD_SIZE,&char_cnt);
00032a  466a              MOV      r2,sp
00032c  2146              MOVS     r1,#0x46
00032e  485a              LDR      r0,|L1.1176|
000330  f7fffffe          BL       getline
000334  9900              LDR      r1,[sp,#0]            ;408
000336  2900              CMP      r1,#0                 ;408
000338  d0f7              BEQ      |L1.810|
;;;411                }
;;;412                if( rc != CMD_SUCCESS)
00033a  2800              CMP      r0,#0
00033c  d116              BNE      |L1.876|
;;;413                {
;;;414                    break;
;;;415                }
;;;416                /* No error check while conversion to integer. If there is an error
;;;417                it will be trapped by wrong checksum */
;;;418                a_to_i(cmd_buf,&recvd_checksum);
00033e  a903              ADD      r1,sp,#0xc
000340  4855              LDR      r0,|L1.1176|
000342  f7fffffe          BL       a_to_i
;;;419                if( checksum == recvd_checksum)
000346  9803              LDR      r0,[sp,#0xc]
000348  4284              CMP      r4,r0
00034a  d104              BNE      |L1.854|
;;;420                {
;;;421                    last_cnt = count;
;;;422                    last_dst = dst;
;;;423                    sendline_crlf((char *)ok);
00034c  4853              LDR      r0,|L1.1180|
00034e  9f02              LDR      r7,[sp,#8]
000350  380a              SUBS     r0,r0,#0xa
000352  9e04              LDR      r6,[sp,#0x10]
000354  e003              B        |L1.862|
                  |L1.854|
;;;424                }
;;;425                else
;;;426                {
;;;427                    count = last_cnt;
;;;428                    dst = last_dst;
;;;429                    sendline_crlf((char *)resend);
000356  4851              LDR      r0,|L1.1180|
000358  9702              STR      r7,[sp,#8]
00035a  1fc0              SUBS     r0,r0,#7
00035c  9604              STR      r6,[sp,#0x10]
                  |L1.862|
00035e  f7fffffe          BL       sendline_crlf
;;;430                }
;;;431                /* line counter and checksum has to be reset anyway */
;;;432                line_ctr = 0;
000362  2500              MOVS     r5,#0
;;;433                checksum = 0;
000364  462c              MOV      r4,r5
                  |L1.870|
000366  9802              LDR      r0,[sp,#8]            ;387
000368  2800              CMP      r0,#0                 ;387
00036a  dcc1              BGT      |L1.752|
                  |L1.876|
;;;434            }
;;;435        }/* While loop */
;;;436    } /* write_to_ram */
00036c  b005              ADD      sp,sp,#0x14
00036e  bdf0              POP      {r4-r7,pc}
;;;437    
                          ENDP

                  read PROC
;;;438    void read(void)
000370  e92d43fe          PUSH     {r1-r9,lr}
;;;439    {
;;;440        unsigned src,checksum,last_src,line_ctr;
;;;441        int count,encode_count,last_cnt;
;;;442        unsigned rc;
;;;443    	int char_cnt;
;;;444    
;;;445        /* Check count validity first as address mapping check requires count */
;;;446        rc = param_check(param_buf[ISP_PARAM_2],(unsigned *)&count,COUNT,NUL);
000374  4d48              LDR      r5,|L1.1176|
000376  2300              MOVS     r3,#0
000378  3594              ADDS     r5,r5,#0x94
00037a  2264              MOVS     r2,#0x64
00037c  a901              ADD      r1,sp,#4
00037e  68a8              LDR      r0,[r5,#8]  ; param_buf
000380  f7fffffe          BL       param_check
000384  0004              MOVS     r4,r0
;;;447        if(rc == 0)
000386  d106              BNE      |L1.918|
;;;448        {
;;;449            rc = param_check(param_buf[ISP_PARAM_1],&src,RAM_OR_FLASH_ADDRESS,count);
000388  6868              LDR      r0,[r5,#4]  ; param_buf
00038a  2266              MOVS     r2,#0x66
00038c  a902              ADD      r1,sp,#8
00038e  9b01              LDR      r3,[sp,#4]
000390  f7fffffe          BL       param_check
000394  4604              MOV      r4,r0
                  |L1.918|
;;;450        }
;;;451        /* Print command result on serial channel */
;;;452        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_0],PARAM_SIZE));
000396  220f              MOVS     r2,#0xf
000398  4620              MOV      r0,r4
00039a  6829              LDR      r1,[r5,#0]  ; param_buf
00039c  f7fffffe          BL       i_to_a
0003a0  f7fffffe          BL       sendline_crlf
;;;453        /* execute command only if parameters are ok */
;;;454        if(rc != CMD_SUCCESS)
0003a4  2c00              CMP      r4,#0
0003a6  d13c              BNE      |L1.1058|
;;;455        {
;;;456            return;
;;;457        }
;;;458        
;;;459        /* Initialize checksum related variables */
;;;460        checksum = 0;
;;;461        line_ctr = 0;
;;;462        last_src = src;
;;;463        last_cnt = count;
0003a8  e9dd0701          LDRD     r0,r7,[sp,#4]
0003ac  2600              MOVS     r6,#0                 ;460
0003ae  4634              MOV      r4,r6                 ;461
0003b0  4680              MOV      r8,r0
;;;464    
;;;465        while(count > 0)
0003b2  e034              B        |L1.1054|
                  |L1.948|
;;;466        {
;;;467            if(count > UU_LINE)
0003b4  2d2d              CMP      r5,#0x2d
0003b6  dd00              BLE      |L1.954|
;;;468            {
;;;469                encode_count = UU_LINE;
0003b8  252d              MOVS     r5,#0x2d
                  |L1.954|
;;;470            }
;;;471            else
;;;472            {
;;;473                encode_count = count;
;;;474            }
;;;475            checksum = checksum + uuencode((char *)src,cmd_buf,encode_count);
0003ba  462a              MOV      r2,r5
0003bc  4936              LDR      r1,|L1.1176|
0003be  9802              LDR      r0,[sp,#8]
0003c0  f7fffffe          BL       uuencode
0003c4  4406              ADD      r6,r6,r0
;;;476            if(sendline_crlf(cmd_buf) != 1)
0003c6  4834              LDR      r0,|L1.1176|
0003c8  f7fffffe          BL       sendline_crlf
0003cc  2801              CMP      r0,#1
0003ce  d128              BNE      |L1.1058|
;;;477            {
;;;478                /* Abort command */
;;;479                break;
;;;480            }
;;;481            /* Keep track of number of lines encoded. Need to send checksum
;;;482               once the LINE_CHECKSUM lines are transmitted */
;;;483            line_ctr++;        
;;;484            src = src + encode_count;
0003d0  9802              LDR      r0,[sp,#8]
0003d2  1c64              ADDS     r4,r4,#1              ;483
0003d4  4428              ADD      r0,r0,r5
;;;485            count = count - encode_count;
0003d6  9002              STR      r0,[sp,#8]
0003d8  9801              LDR      r0,[sp,#4]
0003da  1b40              SUBS     r0,r0,r5
;;;486            if( ((line_ctr == LINE_CHECKSUM) || (count == 0)) )
0003dc  9001              STR      r0,[sp,#4]
0003de  2c14              CMP      r4,#0x14
0003e0  d000              BEQ      |L1.996|
0003e2  b9e0              CBNZ     r0,|L1.1054|
                  |L1.996|
;;;487            {
;;;488                /* Tranmitt checksum string (ASCII decimal) to host */
;;;489                sendline_crlf(i_to_a(checksum,cmd_buf,PARAM_SIZE));
0003e4  220f              MOVS     r2,#0xf
0003e6  492c              LDR      r1,|L1.1176|
0003e8  4630              MOV      r0,r6
0003ea  f7fffffe          BL       i_to_a
0003ee  f7fffffe          BL       sendline_crlf
;;;490                /* Read host response */
;;;491                rc = getline(cmd_buf,CMD_SIZE,&char_cnt);
0003f2  466a              MOV      r2,sp
0003f4  2146              MOVS     r1,#0x46
0003f6  4828              LDR      r0,|L1.1176|
0003f8  f7fffffe          BL       getline
;;;492                if( rc != CMD_SUCCESS)
0003fc  2800              CMP      r0,#0
0003fe  d110              BNE      |L1.1058|
;;;493                {
;;;494                    break;
;;;495                }
;;;496                if(str_cmp(cmd_buf,(char *)ok) == 0)
000400  4926              LDR      r1,|L1.1180|
000402  4825              LDR      r0,|L1.1176|
000404  390a              SUBS     r1,r1,#0xa
000406  f7fffffe          BL       str_cmp
00040a  b918              CBNZ     r0,|L1.1044|
;;;497                {
;;;498                    last_cnt = count;
00040c  9801              LDR      r0,[sp,#4]
;;;499                    last_src = src;
00040e  9f02              LDR      r7,[sp,#8]
000410  4680              MOV      r8,r0                 ;498
000412  e002              B        |L1.1050|
                  |L1.1044|
;;;500                }
;;;501                else
;;;502                {
;;;503                    count = last_cnt;
;;;504                    src = last_src;
000414  e9cd8701          STRD     r8,r7,[sp,#4]
000418  4640              MOV      r0,r8                 ;503
                  |L1.1050|
;;;505                }
;;;506                /* line counter and checksum has to be reset anyway */
;;;507                line_ctr = 0;
00041a  2400              MOVS     r4,#0
;;;508                checksum = 0;
00041c  4626              MOV      r6,r4
                  |L1.1054|
00041e  1e05              SUBS     r5,r0,#0              ;465
000420  dcc8              BGT      |L1.948|
                  |L1.1058|
;;;509            }
;;;510        } /* while count > 0 */
;;;511    } /* read */
000422  e8bd83fe          POP      {r1-r9,pc}
;;;512    
                          ENDP

                  go_cmd PROC
;;;513    void go_cmd(void)
000426  b538              PUSH     {r3-r5,lr}
;;;514    {
;;;515        unsigned rc;
;;;516        void (*go)(void);
;;;517        
;;;518        if(lock == FALSE)
000428  481f              LDR      r0,|L1.1192|
;;;519        {
;;;520            rc = CMD_SUCCESS;
;;;521        }
;;;522        else
;;;523        {
;;;524            rc = CMD_LOCKED;
;;;525        }
;;;526            
;;;527        if(rc == CMD_SUCCESS)
;;;528        {
;;;529            /* Convert and check Go addres */
;;;530            rc = param_check(param_buf[ISP_PARAM_1],(unsigned *)&go, \
00042a  4d1b              LDR      r5,|L1.1176|
00042c  6800              LDR      r0,[r0,#0]            ;518  ; lock
00042e  3594              ADDS     r5,r5,#0x94
000430  b980              CBNZ     r0,|L1.1108|
000432  2300              MOVS     r3,#0
000434  2266              MOVS     r2,#0x66
000436  4669              MOV      r1,sp
000438  6868              LDR      r0,[r5,#4]  ; param_buf
00043a  f7fffffe          BL       param_check
00043e  0004              MOVS     r4,r0
;;;531                 RAM_OR_FLASH_ADDRESS,NUL);
;;;532        }
;;;533        
;;;534        if(rc == CMD_SUCCESS)
000440  d10b              BNE      |L1.1114|
;;;535        {
;;;536            /* Check for processor mode switch */
;;;537            if(*(param_buf[ISP_PARAM_2]) == 'T')
000442  68a8              LDR      r0,[r5,#8]  ; param_buf
000444  7800              LDRB     r0,[r0,#0]
000446  2854              CMP      r0,#0x54
000448  d106              BNE      |L1.1112|
;;;538            {
;;;539                /* ARM Thumb compiler generates BX instruction when pointer 
;;;540                to a function is used. Set last bit of the address to 1 
;;;541                to prevent mode switch to ARM */
;;;542                go = (void(*)(void))( ((unsigned)(go) | 0x1) );
00044a  9800              LDR      r0,[sp,#0]
00044c  f0400001          ORR      r0,r0,#1
000450  9000              STR      r0,[sp,#0]
000452  e002              B        |L1.1114|
                  |L1.1108|
000454  240f              MOVS     r4,#0xf               ;524
000456  e000              B        |L1.1114|
                  |L1.1112|
;;;543            }
;;;544            else
;;;545            {
;;;546                /* Mode parameter is not specified or incorrect */
;;;547                rc = PARAM_ERROR;
000458  240c              MOVS     r4,#0xc
                  |L1.1114|
;;;548            }
;;;549        }
;;;550        /* Print command result on serial channel */
;;;551        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_1],PARAM_SIZE));
00045a  220f              MOVS     r2,#0xf
00045c  4620              MOV      r0,r4
00045e  6869              LDR      r1,[r5,#4]  ; param_buf
000460  f7fffffe          BL       i_to_a
000464  f7fffffe          BL       sendline_crlf
;;;552        /* execute command only if all the parameters are ok */
;;;553        if(rc == CMD_SUCCESS)
000468  2c00              CMP      r4,#0
00046a  d103              BNE      |L1.1140|
;;;554        {
;;;555    	    /* revert any peripheral changes */
;;;556            Timer_DeInit();
00046c  f7fffffe          BL       Timer_DeInit
;;;557            go();
000470  9800              LDR      r0,[sp,#0]
000472  4780              BLX      r0
                  |L1.1140|
;;;558        }
;;;559    } /* go */
000474  bd38              POP      {r3-r5,pc}
;;;560    
                          ENDP

                  unlock PROC
;;;561    void unlock(void)
000476  b538              PUSH     {r3-r5,lr}
;;;562    {
;;;563        int u_code;
;;;564        unsigned rc;
;;;565        rc = param_check(param_buf[ISP_PARAM_1],(unsigned *)&u_code,NO_PARAM_CHECK,NUL);
000478  4c07              LDR      r4,|L1.1176|
00047a  2300              MOVS     r3,#0
00047c  3494              ADDS     r4,r4,#0x94
00047e  2269              MOVS     r2,#0x69
000480  4669              MOV      r1,sp
000482  6860              LDR      r0,[r4,#4]  ; param_buf
000484  f7fffffe          BL       param_check
;;;566        /* execute command only if parameters are ok */
;;;567        if(rc == 0)
000488  b9b0              CBNZ     r0,|L1.1208|
;;;568        {
;;;569            if(u_code == unlock_code)
00048a  9900              LDR      r1,[sp,#0]
00048c  f5a142b4          SUB      r2,r1,#0x5a00
000490  3a5a              SUBS     r2,r2,#0x5a
000492  d110              BNE      |L1.1206|
;;;570            {
;;;571                lock = FALSE;    
000494  2100              MOVS     r1,#0
000496  e00b              B        |L1.1200|
                  |L1.1176|
                          DCD      ||.bss||
                  |L1.1180|
                          DCD      ||area_number.6||+0xa
                  |L1.1184|
                          DCD      0x10008000
                  |L1.1188|
                          DCD      0x1fff1ff1
                  |L1.1192|
                          DCD      ||.data||
                  |L1.1196|
                          DCD      0x12345678
                  |L1.1200|
0004b0  4afb              LDR      r2,|L1.2208|
0004b2  6011              STR      r1,[r2,#0]  ; lock
0004b4  e000              B        |L1.1208|
                  |L1.1206|
;;;572            }
;;;573            else
;;;574            {
;;;575                rc = INVALID_CODE;
0004b6  2010              MOVS     r0,#0x10
                  |L1.1208|
;;;576            }
;;;577        }
;;;578        /* Print command result on serial channel */
;;;579        sendline_crlf(i_to_a(rc,param_buf[ISP_PARAM_1],PARAM_SIZE));
0004b8  220f              MOVS     r2,#0xf
0004ba  6861              LDR      r1,[r4,#4]  ; param_buf
0004bc  f7fffffe          BL       i_to_a
0004c0  f7fffffe          BL       sendline_crlf
;;;580    } /* unlock */
0004c4  bd38              POP      {r3-r5,pc}
;;;581    
                          ENDP

                  prepare_sector PROC
;;;582    void prepare_sector(void)
0004c6  b570              PUSH     {r4-r6,lr}
;;;583    {
;;;584        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;585           done in IAP prepare sector for write. Parameter type is deliberately 
;;;586           set to NO_PARAM_CHECK so that param_check function just converts ascii 
;;;587           to integer 
;;;588        */
;;;589        result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
0004c8  4cf6              LDR      r4,|L1.2212|
0004ca  2300              MOVS     r3,#0
0004cc  f1040614          ADD      r6,r4,#0x14
0004d0  2269              MOVS     r2,#0x69
0004d2  1d31              ADDS     r1,r6,#4
0004d4  6860              LDR      r0,[r4,#4]  ; param_buf
0004d6  f7fffffe          BL       param_check
0004da  f1040528          ADD      r5,r4,#0x28
;;;590        &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;591    
;;;592        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0004de  6028              STR      r0,[r5,#0]  ; result_table
0004e0  b970              CBNZ     r0,|L1.1280|
;;;593        {
;;;594            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
0004e2  2300              MOVS     r3,#0
0004e4  2269              MOVS     r2,#0x69
0004e6  f104011c          ADD      r1,r4,#0x1c
0004ea  68a0              LDR      r0,[r4,#8]  ; param_buf
0004ec  f7fffffe          BL       param_check
;;;595            &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;596        }
;;;597            
;;;598        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0004f0  6028              STR      r0,[r5,#0]  ; result_table
0004f2  b928              CBNZ     r0,|L1.1280|
;;;599        {
;;;600            param_table[IAP_CMD_CODE] = PREPARE_SECTOR_FOR_WRITE;
0004f4  2032              MOVS     r0,#0x32
0004f6  4aec              LDR      r2,|L1.2216|
0004f8  6030              STR      r0,[r6,#0]  ; param_table
0004fa  4629              MOV      r1,r5
0004fc  4630              MOV      r0,r6
0004fe  4790              BLX      r2
                  |L1.1280|
;;;601            iap_entry(param_table,result_table);
;;;602        }
;;;603        sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000500  6861              LDR      r1,[r4,#4]  ; param_buf
000502  220f              MOVS     r2,#0xf
000504  6828              LDR      r0,[r5,#0]  ; result_table
000506  f7fffffe          BL       i_to_a
00050a  e8bd4070          POP      {r4-r6,lr}
00050e  f7ffbffe          B.W      sendline_crlf
;;;604        PARAM_SIZE));
;;;605    } /* prepare_sector */
;;;606    
                          ENDP

                  copy PROC
;;;607    void copy(void)
000512  e92d41f0          PUSH     {r4-r8,lr}
;;;608    {
;;;609        if(lock == TRUE)
000516  4fe2              LDR      r7,|L1.2208|
;;;610        {
;;;611            sendline_crlf(i_to_a(CMD_LOCKED,param_buf[ISP_PARAM_1],PARAM_SIZE));
000518  4ee2              LDR      r6,|L1.2212|
00051a  6839              LDR      r1,[r7,#0]  ; lock
00051c  6870              LDR      r0,[r6,#4]            ;609
00051e  2901              CMP      r1,#1                 ;609
000520  d103              BNE      |L1.1322|
000522  220f              MOVS     r2,#0xf
000524  4601              MOV      r1,r0
000526  4610              MOV      r0,r2
000528  e036              B        |L1.1432|
                  |L1.1322|
;;;612        }
;;;613        else
;;;614        {
;;;615        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;616        done in IAP copy RAM to FLASH.Parameter type is deliberately 
;;;617        set to NO_PARAM_CHECK so that param_check function just converts ascii to integer
;;;618        */
;;;619            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
00052a  4dde              LDR      r5,|L1.2212|
00052c  2300              MOVS     r3,#0
00052e  3514              ADDS     r5,r5,#0x14
000530  2269              MOVS     r2,#0x69
000532  1d29              ADDS     r1,r5,#4
000534  f7fffffe          BL       param_check
000538  f1050414          ADD      r4,r5,#0x14
;;;620            &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;621    
;;;622            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
00053c  6020              STR      r0,[r4,#0]  ; result_table
00053e  b980              CBNZ     r0,|L1.1378|
;;;623            {
;;;624                result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
000540  2300              MOVS     r3,#0
000542  2269              MOVS     r2,#0x69
000544  f1a4010c          SUB      r1,r4,#0xc
000548  68b0              LDR      r0,[r6,#8]  ; param_buf
00054a  f7fffffe          BL       param_check
;;;625                &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;626            }
;;;627    
;;;628            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
00054e  6020              STR      r0,[r4,#0]  ; result_table
000550  b938              CBNZ     r0,|L1.1378|
;;;629            {
;;;630                result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_3], \
000552  2300              MOVS     r3,#0
000554  2269              MOVS     r2,#0x69
000556  f1a40108          SUB      r1,r4,#8
00055a  68f0              LDR      r0,[r6,#0xc]  ; param_buf
00055c  f7fffffe          BL       param_check
000560  6020              STR      r0,[r4,#0]  ; result_table
                  |L1.1378|
;;;631                &param_table[IAP_PARAM_2],NO_PARAM_CHECK,NUL);
;;;632            }
;;;633    
;;;634            /* Do not allow write to USER Start sector */
;;;635            if( (crp_after_reset == CRP1) )
000562  49d2              LDR      r1,|L1.2220|
000564  6878              LDR      r0,[r7,#4]  ; crp_after_reset
000566  4288              CMP      r0,r1
000568  d106              BNE      |L1.1400|
;;;636            {
;;;637                if( (param_table[IAP_PARAM_0] < (USER_START_SECTOR_ADDRESS+USER_START_SECTOR_SIZE)) )
00056a  6868              LDR      r0,[r5,#4]  ; param_table
00056c  f5b05f40          CMP      r0,#0x3000
000570  d202              BCS      |L1.1400|
;;;638                {
;;;639                    result_table[IAP_STAT_CODE] = CODE_READ_PROTECTION_ENABLED;
000572  2013              MOVS     r0,#0x13
000574  6020              STR      r0,[r4,#0]  ; result_table
000576  e00c              B        |L1.1426|
                  |L1.1400|
;;;640                }
;;;641            }
;;;642    
;;;643            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000578  6820              LDR      r0,[r4,#0]  ; result_table
00057a  b950              CBNZ     r0,|L1.1426|
;;;644            {
;;;645                param_table[IAP_CMD_CODE] = COPY_RAM_TO_FLASH;
00057c  2033              MOVS     r0,#0x33
;;;646                param_table[IAP_PARAM_3] = fcclk_KHz;
00057e  6028              STR      r0,[r5,#0]  ; param_table
000580  49c8              LDR      r1,|L1.2212|
000582  f44f407a          MOV      r0,#0xfa00
000586  4ac8              LDR      r2,|L1.2216|
000588  3128              ADDS     r1,r1,#0x28
00058a  6128              STR      r0,[r5,#0x10]  ; param_table
00058c  f1a10014          SUB      r0,r1,#0x14
000590  4790              BLX      r2
                  |L1.1426|
;;;647                iap_entry(param_table,result_table);
;;;648            }
;;;649            sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000592  6871              LDR      r1,[r6,#4]  ; param_buf
000594  220f              MOVS     r2,#0xf
000596  6820              LDR      r0,[r4,#0]  ; result_table
                  |L1.1432|
000598  f7fffffe          BL       i_to_a
00059c  e8bd41f0          POP      {r4-r8,lr}
0005a0  f7ffbffe          B.W      sendline_crlf
;;;650            PARAM_SIZE));
;;;651        }
;;;652    } /* copy */
;;;653    
                          ENDP

                  erase PROC
;;;654    void erase(void)
0005a4  e92d41f0          PUSH     {r4-r8,lr}
;;;655    {
;;;656        if(lock == TRUE)
0005a8  4fbd              LDR      r7,|L1.2208|
;;;657        {
;;;658            sendline_crlf(i_to_a(CMD_LOCKED,param_buf[ISP_PARAM_1],PARAM_SIZE));
0005aa  4ebe              LDR      r6,|L1.2212|
0005ac  6839              LDR      r1,[r7,#0]  ; lock
0005ae  6870              LDR      r0,[r6,#4]            ;656
0005b0  2901              CMP      r1,#1                 ;656
0005b2  d103              BNE      |L1.1468|
0005b4  220f              MOVS     r2,#0xf
0005b6  4601              MOV      r1,r0
0005b8  4610              MOV      r0,r2
0005ba  e046              B        |L1.1610|
                  |L1.1468|
;;;659        }
;;;660        else
;;;661        {
;;;662        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;663           done in IAP erase sector. Parameter type is deliberately 
;;;664           set to NO_PARAM_CHECK so that param_check function just converts ascii to integer 
;;;665        */
;;;666            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
0005bc  4db9              LDR      r5,|L1.2212|
0005be  2300              MOVS     r3,#0
0005c0  3514              ADDS     r5,r5,#0x14
0005c2  2269              MOVS     r2,#0x69
0005c4  1d29              ADDS     r1,r5,#4
0005c6  f7fffffe          BL       param_check
0005ca  f1050414          ADD      r4,r5,#0x14
;;;667            &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;668    
;;;669            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0005ce  6020              STR      r0,[r4,#0]  ; result_table
0005d0  b938              CBNZ     r0,|L1.1506|
;;;670            {
;;;671                result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
0005d2  2300              MOVS     r3,#0
0005d4  2269              MOVS     r2,#0x69
0005d6  f1a4010c          SUB      r1,r4,#0xc
0005da  68b0              LDR      r0,[r6,#8]  ; param_buf
0005dc  f7fffffe          BL       param_check
0005e0  6020              STR      r0,[r4,#0]  ; result_table
                  |L1.1506|
;;;672                &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;673            }
;;;674    
;;;675            /* If code read protection level 2 or 3 is enabled allow erase command only when
;;;676               all sectors are selected for erase */
;;;677            if( (crp_after_reset == CRP2) ||                     \
0005e2  4ab3              LDR      r2,|L1.2224|
0005e4  6878              LDR      r0,[r7,#4]  ; crp_after_reset
;;;678                (crp_after_reset == CRP3) 
;;;679               )
;;;680            {
;;;681                if( (param_table[IAP_PARAM_0] != USER_START_SECTOR) ||                         \
;;;682                    (param_table[IAP_PARAM_1] != USER_END_SECTOR)
;;;683                  )
;;;684                {
;;;685                    result_table[IAP_STAT_CODE] = CODE_READ_PROTECTION_ENABLED;
0005e6  2113              MOVS     r1,#0x13
0005e8  4290              CMP      r0,r2                 ;677
0005ea  d003              BEQ      |L1.1524|
0005ec  ea4f4232          ROR      r2,r2,#16             ;678
0005f0  4290              CMP      r0,r2                 ;678
0005f2  d107              BNE      |L1.1540|
                  |L1.1524|
0005f4  6868              LDR      r0,[r5,#4]            ;681  ; param_table
0005f6  2802              CMP      r0,#2                 ;681
0005f8  d102              BNE      |L1.1536|
0005fa  68a8              LDR      r0,[r5,#8]            ;682  ; param_table
0005fc  281d              CMP      r0,#0x1d              ;682
0005fe  d00c              BEQ      |L1.1562|
                  |L1.1536|
000600  6021              STR      r1,[r4,#0]  ; result_table
000602  e017              B        |L1.1588|
                  |L1.1540|
;;;686                }
;;;687            }
;;;688    
;;;689            /* If code read protection level 1 is enabled allow erase command only when
;;;690               user start sector is NOT selected for erase */
;;;691            else if( (crp_after_reset == CRP1) )
000604  4aa9              LDR      r2,|L1.2220|
000606  4290              CMP      r0,r2
000608  d107              BNE      |L1.1562|
;;;692            {
;;;693               if( (param_table[IAP_PARAM_0] == USER_START_SECTOR) &&                         \
00060a  6868              LDR      r0,[r5,#4]  ; param_table
00060c  2802              CMP      r0,#2
00060e  d104              BNE      |L1.1562|
;;;694                   (param_table[IAP_PARAM_1] != USER_END_SECTOR)
000610  68a8              LDR      r0,[r5,#8]  ; param_table
000612  281d              CMP      r0,#0x1d
000614  d001              BEQ      |L1.1562|
;;;695                 )
;;;696                {
;;;697                    result_table[IAP_STAT_CODE] = CODE_READ_PROTECTION_ENABLED;
000616  6021              STR      r1,[r4,#0]  ; result_table
000618  e014              B        |L1.1604|
                  |L1.1562|
;;;698                }
;;;699            }
;;;700    
;;;701            if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
00061a  6820              LDR      r0,[r4,#0]  ; result_table
00061c  b950              CBNZ     r0,|L1.1588|
;;;702            {
;;;703                param_table[IAP_CMD_CODE] = ERASE_SECTOR;
00061e  2034              MOVS     r0,#0x34
;;;704                param_table[IAP_PARAM_2] = fcclk_KHz;
000620  6028              STR      r0,[r5,#0]  ; param_table
000622  49a0              LDR      r1,|L1.2212|
000624  f44f407a          MOV      r0,#0xfa00
000628  4a9f              LDR      r2,|L1.2216|
00062a  3128              ADDS     r1,r1,#0x28
00062c  60e8              STR      r0,[r5,#0xc]  ; param_table
00062e  f1a10014          SUB      r0,r1,#0x14
000632  4790              BLX      r2
                  |L1.1588|
;;;705                iap_entry(param_table,result_table);
;;;706            }
;;;707            /* Update code protection status if all sectors are erased */
;;;708            if( (param_table[IAP_PARAM_0] == USER_START_SECTOR) &&                         \
000634  6868              LDR      r0,[r5,#4]  ; param_table
000636  2802              CMP      r0,#2
000638  d104              BNE      |L1.1604|
;;;709                (param_table[IAP_PARAM_1] == USER_END_SECTOR)
00063a  68a8              LDR      r0,[r5,#8]  ; param_table
00063c  281d              CMP      r0,#0x1d
00063e  d101              BNE      |L1.1604|
;;;710              )
;;;711            {
;;;712                crp_after_reset = NOCRP;       
000640  489c              LDR      r0,|L1.2228|
000642  6078              STR      r0,[r7,#4]  ; crp_after_reset
                  |L1.1604|
;;;713            }
;;;714            sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000644  6871              LDR      r1,[r6,#4]  ; param_buf
000646  220f              MOVS     r2,#0xf
000648  6820              LDR      r0,[r4,#0]  ; result_table
                  |L1.1610|
00064a  f7fffffe          BL       i_to_a
00064e  e8bd41f0          POP      {r4-r8,lr}
000652  f7ffbffe          B.W      sendline_crlf
;;;715            PARAM_SIZE));
;;;716        }
;;;717    } /* erase */
;;;718    
                          ENDP

                  blank_check PROC
;;;719    void blank_check(void)
000656  b570              PUSH     {r4-r6,lr}
;;;720    {
;;;721        /* Convert ascii string to integer. Do not validate sector numbers as it is
;;;722           done in IAP blank check sector. Parameter type is deliberately 
;;;723           set to NO_PARAM_CHECK so that param_check function just converts ascii 
;;;724           to integer
;;;725        */
;;;726        result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
000658  4c92              LDR      r4,|L1.2212|
00065a  2300              MOVS     r3,#0
00065c  f1040614          ADD      r6,r4,#0x14
000660  2269              MOVS     r2,#0x69
000662  1d31              ADDS     r1,r6,#4
000664  6860              LDR      r0,[r4,#4]  ; param_buf
000666  f7fffffe          BL       param_check
00066a  f1040528          ADD      r5,r4,#0x28
;;;727        &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;728        
;;;729        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
00066e  6028              STR      r0,[r5,#0]  ; result_table
000670  b970              CBNZ     r0,|L1.1680|
;;;730        {
;;;731            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
000672  2300              MOVS     r3,#0
000674  2269              MOVS     r2,#0x69
000676  f104011c          ADD      r1,r4,#0x1c
00067a  68a0              LDR      r0,[r4,#8]  ; param_buf
00067c  f7fffffe          BL       param_check
;;;732            &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;733        }    
;;;734        
;;;735        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000680  6028              STR      r0,[r5,#0]  ; result_table
000682  b928              CBNZ     r0,|L1.1680|
;;;736        {
;;;737            param_table[IAP_CMD_CODE] = BLANK_CHECK_SECTOR;
000684  2035              MOVS     r0,#0x35
000686  4a88              LDR      r2,|L1.2216|
000688  6030              STR      r0,[r6,#0]  ; param_table
00068a  4629              MOV      r1,r5
00068c  4630              MOV      r0,r6
00068e  4790              BLX      r2
                  |L1.1680|
;;;738            iap_entry(param_table,result_table);
;;;739        }
;;;740        sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000690  6861              LDR      r1,[r4,#4]  ; param_buf
000692  220f              MOVS     r2,#0xf
000694  6828              LDR      r0,[r5,#0]  ; result_table
000696  f7fffffe          BL       i_to_a
00069a  f7fffffe          BL       sendline_crlf
;;;741        PARAM_SIZE));
;;;742        if(result_table[IAP_STAT_CODE] == SECTOR_NOT_BLANK)
00069e  6828              LDR      r0,[r5,#0]  ; result_table
0006a0  2808              CMP      r0,#8
0006a2  d11e              BNE      |L1.1762|
;;;743        {
;;;744            if( ( (crp_after_reset == CRP1)       ||       \
0006a4  487e              LDR      r0,|L1.2208|
0006a6  4981              LDR      r1,|L1.2220|
0006a8  6840              LDR      r0,[r0,#4]  ; crp_after_reset
0006aa  4288              CMP      r0,r1
0006ac  d006              BEQ      |L1.1724|
;;;745                  (crp_after_reset == CRP2)       ||       \
0006ae  4980              LDR      r1,|L1.2224|
0006b0  4288              CMP      r0,r1
0006b2  d003              BEQ      |L1.1724|
;;;746                  (crp_after_reset == CRP3) )              \
0006b4  ea4f4131          ROR      r1,r1,#16
0006b8  4288              CMP      r0,r1
0006ba  d102              BNE      |L1.1730|
                  |L1.1724|
;;;747              )
;;;748            {
;;;749                result_table[IAP_RESULT_0]=0;
0006bc  2000              MOVS     r0,#0
;;;750                result_table[IAP_RESULT_1]=0;
0006be  6068              STR      r0,[r5,#4]  ; result_table
0006c0  60a8              STR      r0,[r5,#8]  ; result_table
                  |L1.1730|
;;;751            }
;;;752            sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
0006c2  6861              LDR      r1,[r4,#4]  ; param_buf
0006c4  220f              MOVS     r2,#0xf
0006c6  6868              LDR      r0,[r5,#4]  ; result_table
0006c8  f7fffffe          BL       i_to_a
0006cc  f7fffffe          BL       sendline_crlf
;;;753            PARAM_SIZE));
;;;754            sendline_crlf(i_to_a(result_table[IAP_RESULT_1],param_buf[ISP_PARAM_1], \
0006d0  6861              LDR      r1,[r4,#4]  ; param_buf
0006d2  220f              MOVS     r2,#0xf
0006d4  68a8              LDR      r0,[r5,#8]  ; result_table
0006d6  f7fffffe          BL       i_to_a
0006da  e8bd4070          POP      {r4-r6,lr}
0006de  f7ffbffe          B.W      sendline_crlf
                  |L1.1762|
;;;755            PARAM_SIZE));
;;;756        }
;;;757    } /* blank_check */
0006e2  bd70              POP      {r4-r6,pc}
;;;758    
                          ENDP

                  compare_mem PROC
;;;759    void compare_mem(void)
0006e4  b570              PUSH     {r4-r6,lr}
;;;760    {
;;;761        /* Convert ascii string to integer. Do not validate address & count as it is
;;;762        done in IAP COMPARE command.Parameter type is deliberately 
;;;763        set to NO_PARAM_CHECK so that param_check function just converts ascii to integer
;;;764        */
;;;765        result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_1], \
0006e6  4c6f              LDR      r4,|L1.2212|
0006e8  2300              MOVS     r3,#0
0006ea  f1040614          ADD      r6,r4,#0x14
0006ee  2269              MOVS     r2,#0x69
0006f0  1d31              ADDS     r1,r6,#4
0006f2  6860              LDR      r0,[r4,#4]  ; param_buf
0006f4  f7fffffe          BL       param_check
0006f8  f1040528          ADD      r5,r4,#0x28
;;;766        &param_table[IAP_PARAM_0],NO_PARAM_CHECK,NUL);
;;;767    
;;;768        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0006fc  6028              STR      r0,[r5,#0]  ; result_table
0006fe  b9b8              CBNZ     r0,|L1.1840|
;;;769        {
;;;770            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_2], \
000700  2300              MOVS     r3,#0
000702  2269              MOVS     r2,#0x69
000704  f104011c          ADD      r1,r4,#0x1c
000708  68a0              LDR      r0,[r4,#8]  ; param_buf
00070a  f7fffffe          BL       param_check
;;;771            &param_table[IAP_PARAM_1],NO_PARAM_CHECK,NUL);
;;;772        }
;;;773    
;;;774        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
00070e  6028              STR      r0,[r5,#0]  ; result_table
000710  b970              CBNZ     r0,|L1.1840|
;;;775        {
;;;776            result_table[IAP_STAT_CODE] = param_check(param_buf[ISP_PARAM_3], \
000712  2300              MOVS     r3,#0
000714  2269              MOVS     r2,#0x69
000716  f1040120          ADD      r1,r4,#0x20
00071a  68e0              LDR      r0,[r4,#0xc]  ; param_buf
00071c  f7fffffe          BL       param_check
;;;777            &param_table[IAP_PARAM_2],NO_PARAM_CHECK,NUL);
;;;778        }
;;;779    
;;;780        if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
000720  6028              STR      r0,[r5,#0]  ; result_table
000722  b928              CBNZ     r0,|L1.1840|
;;;781        {
;;;782            param_table[IAP_CMD_CODE] = COMPARE;
000724  2038              MOVS     r0,#0x38
000726  4a60              LDR      r2,|L1.2216|
000728  6030              STR      r0,[r6,#0]  ; param_table
00072a  4629              MOV      r1,r5
00072c  4630              MOV      r0,r6
00072e  4790              BLX      r2
                  |L1.1840|
;;;783            iap_entry(param_table,result_table);
;;;784        }
;;;785        sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000730  6861              LDR      r1,[r4,#4]  ; param_buf
000732  220f              MOVS     r2,#0xf
000734  6828              LDR      r0,[r5,#0]  ; result_table
000736  f7fffffe          BL       i_to_a
00073a  f7fffffe          BL       sendline_crlf
;;;786        PARAM_SIZE));
;;;787        if(result_table[IAP_STAT_CODE] == COMPARE_ERROR)
00073e  6828              LDR      r0,[r5,#0]  ; result_table
000740  280a              CMP      r0,#0xa
000742  d108              BNE      |L1.1878|
;;;788        {
;;;789            sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
000744  6861              LDR      r1,[r4,#4]  ; param_buf
000746  220f              MOVS     r2,#0xf
000748  6868              LDR      r0,[r5,#4]  ; result_table
00074a  f7fffffe          BL       i_to_a
00074e  e8bd4070          POP      {r4-r6,lr}
000752  f7ffbffe          B.W      sendline_crlf
                  |L1.1878|
;;;790            PARAM_SIZE));
;;;791        }
;;;792    }
000756  bd70              POP      {r4-r6,pc}
;;;793    
                          ENDP

                  tokenize PROC
;;;794    int tokenize(char * in_buf,int no_of_chars_in_inbuf,char * out_buf[],   \
000758  e92d41f0          PUSH     {r4-r8,lr}
;;;795                 int max_tokens,int max_chars_per_token )
;;;796    {
00075c  4606              MOV      r6,r0
00075e  4688              MOV      r8,r1
;;;797        int i,token_count=0,pos=0, chars_in_token=0;
000760  2000              MOVS     r0,#0
;;;798    
;;;799        if(in_buf[0] == NUL)
000762  7831              LDRB     r1,[r6,#0]
000764  9f06              LDR      r7,[sp,#0x18]
000766  4604              MOV      r4,r0                 ;797
000768  4605              MOV      r5,r0                 ;797
00076a  b909              CBNZ     r1,|L1.1904|
                  |L1.1900|
;;;800        {
;;;801            return(0);
;;;802        }
;;;803        for(i=0;i<=no_of_chars_in_inbuf;i++)
;;;804        {
;;;805            if( token_count+1 > max_tokens)
;;;806            {
;;;807                return(token_count+1);
;;;808            }
;;;809            
;;;810            if( (in_buf[i] != SP)  &&                                      \
;;;811                (chars_in_token < (max_chars_per_token -2)) )
;;;812            {
;;;813                *(out_buf[token_count]+pos) = in_buf[i];
;;;814                pos++;
;;;815                chars_in_token++;
;;;816            }
;;;817            else if( (in_buf[i+1] != SP) ||                                \
;;;818                     (chars_in_token == (max_chars_per_token -2)) )
;;;819            {
;;;820                *(out_buf[token_count]+pos) = NUL;
;;;821                token_count++;
;;;822                pos=0;
;;;823                chars_in_token=0;
;;;824            }            
;;;825        }
;;;826        return(token_count+1);
;;;827    } /* tokenize */
00076c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1904|
000770  2100              MOVS     r1,#0                 ;803
000772  1ebf              SUBS     r7,r7,#2              ;811
000774  e023              B        |L1.1982|
000776  bf00              NOP                            ;805
                  |L1.1912|
000778  f1000c01          ADD      r12,r0,#1             ;805
00077c  459c              CMP      r12,r3                ;805
00077e  dc20              BGT      |L1.1986|
000780  f816c001          LDRB     r12,[r6,r1]           ;810
000784  f1bc0f20          CMP      r12,#0x20             ;810
000788  d008              BEQ      |L1.1948|
00078a  42bd              CMP      r5,r7                 ;811
00078c  da06              BGE      |L1.1948|
00078e  f852e020          LDR      lr,[r2,r0,LSL #2]     ;813
000792  f80ec004          STRB     r12,[lr,r4]           ;813
000796  1c64              ADDS     r4,r4,#1              ;814
000798  1c6d              ADDS     r5,r5,#1              ;815
00079a  e00f              B        |L1.1980|
                  |L1.1948|
00079c  eb060c01          ADD      r12,r6,r1             ;817
0007a0  f89cc001          LDRB     r12,[r12,#1]          ;817
0007a4  f1bc0f20          CMP      r12,#0x20             ;817
0007a8  d101              BNE      |L1.1966|
0007aa  42bd              CMP      r5,r7                 ;818
0007ac  d106              BNE      |L1.1980|
                  |L1.1966|
0007ae  2500              MOVS     r5,#0                 ;820
0007b0  f852c020          LDR      r12,[r2,r0,LSL #2]    ;820
0007b4  1c40              ADDS     r0,r0,#1              ;821
0007b6  f80c5004          STRB     r5,[r12,r4]           ;820
0007ba  462c              MOV      r4,r5                 ;822
                  |L1.1980|
0007bc  1c49              ADDS     r1,r1,#1              ;803
                  |L1.1982|
0007be  4541              CMP      r1,r8                 ;803
0007c0  ddda              BLE      |L1.1912|
                  |L1.1986|
0007c2  1c40              ADDS     r0,r0,#1              ;826
0007c4  e7d2              B        |L1.1900|
;;;828    
                          ENDP

                  enable_interrupts PROC
;;;829    void enable_interrupts(unsigned interrupts)
0007c6  b662              CPSIE    i
;;;830    {
;;;831      __enable_irq();
;;;832    }
0007c8  4770              BX       lr
;;;833    
                          ENDP

                  disable_interrupts PROC
;;;834    void disable_interrupts(unsigned interrupts)
0007ca  b672              CPSID    i
;;;835    {
;;;836      __disable_irq();
;;;837    }
0007cc  4770              BX       lr
;;;838    
                          ENDP

                  execute_user_code PROC
;;;839    void execute_user_code(void)
0007ce  f2420001          MOV      r0,#0x2001
;;;840    {
;;;841        void (*user_code_entry)(void);
;;;842        user_code_entry = (void (*)(void))(USER_START_SECTOR_ADDRESS | 0x00000001);
;;;843        user_code_entry();
0007d2  4700              BX       r0
;;;844    }
;;;845    
                          ENDP

                  user_code_present PROC
;;;846    unsigned user_code_present(void)
0007d4  4833              LDR      r0,|L1.2212|
;;;847    {
0007d6  b510              PUSH     {r4,lr}
;;;848        param_table[IAP_CMD_CODE] = BLANK_CHECK_SECTOR;
0007d8  2135              MOVS     r1,#0x35
0007da  3014              ADDS     r0,r0,#0x14
;;;849        param_table[IAP_PARAM_0] = USER_START_SECTOR;
0007dc  6001              STR      r1,[r0,#0]  ; param_table
0007de  2102              MOVS     r1,#2
;;;850        param_table[IAP_PARAM_1] = USER_START_SECTOR;
0007e0  6041              STR      r1,[r0,#4]  ; param_table
0007e2  4a31              LDR      r2,|L1.2216|
0007e4  6081              STR      r1,[r0,#8]  ; param_table
0007e6  f1000114          ADD      r1,r0,#0x14
0007ea  4790              BLX      r2
;;;851        iap_entry(param_table,result_table);
;;;852    	if( result_table[IAP_STAT_CODE] == CMD_SUCCESS )
0007ec  482d              LDR      r0,|L1.2212|
0007ee  3028              ADDS     r0,r0,#0x28
0007f0  6800              LDR      r0,[r0,#0]  ; result_table
0007f2  2800              CMP      r0,#0
0007f4  d000              BEQ      |L1.2040|
;;;853    	{
;;;854    	    return (FALSE);
;;;855    	}
;;;856    	else
;;;857    	{
;;;858    	    return (TRUE);
0007f6  2001              MOVS     r0,#1
                  |L1.2040|
;;;859    	}
;;;860    }
0007f8  bd10              POP      {r4,pc}
;;;861    
                          ENDP

                  check_isp_entry_pin PROC
;;;862    unsigned check_isp_entry_pin(void)
0007fa  482f              LDR      r0,|L1.2232|
;;;863    {
;;;864      if( (*(volatile unsigned *)ISP_ENTRY_GPIO_REG) & (0x1<<ISP_ENTRY_PIN) )
0007fc  6940              LDR      r0,[r0,#0x14]
0007fe  0400              LSLS     r0,r0,#16
000800  d501              BPL      |L1.2054|
;;;865    	{
;;;866    	    return(TRUE);
000802  2001              MOVS     r0,#1
;;;867    	}
;;;868    	else
;;;869    	{
;;;870    	    return(FALSE);
;;;871    	}
;;;872    }
000804  4770              BX       lr
                  |L1.2054|
000806  2000              MOVS     r0,#0                 ;870
000808  4770              BX       lr
;;;873    
                          ENDP

                  is_LPC175x PROC
;;;875    /* returns TRUE if device is an LPC175x */
;;;876    int is_LPC175x(void)
00080a  4926              LDR      r1,|L1.2212|
;;;877    {
00080c  b510              PUSH     {r4,lr}
;;;878      param_table[IAP_CMD_CODE] = READ_PART_ID;
00080e  2036              MOVS     r0,#0x36
000810  3114              ADDS     r1,r1,#0x14
000812  6008              STR      r0,[r1,#0]  ; param_table
000814  4a24              LDR      r2,|L1.2216|
000816  3114              ADDS     r1,r1,#0x14
000818  f1a10014          SUB      r0,r1,#0x14
00081c  4790              BLX      r2
;;;879      iap_entry(param_table,result_table);
;;;880      if ((result_table[ISP_PARAM_1] >> 24) == 0x25)
00081e  4821              LDR      r0,|L1.2212|
000820  2125              MOVS     r1,#0x25
000822  3028              ADDS     r0,r0,#0x28
000824  6840              LDR      r0,[r0,#4]  ; result_table
000826  ebb16f10          CMP      r1,r0,LSR #24
00082a  d101              BNE      |L1.2096|
;;;881      {
;;;882        return TRUE;
00082c  2001              MOVS     r0,#1
;;;883      }
;;;884    
;;;885      return FALSE;
;;;886    }
00082e  bd10              POP      {r4,pc}
                  |L1.2096|
000830  2000              MOVS     r0,#0                 ;885
000832  bd10              POP      {r4,pc}
;;;887    
                          ENDP

                  exec_isp_cmd PROC
;;;888    void exec_isp_cmd(int no_of_param)
000834  b570              PUSH     {r4-r6,lr}
;;;889    {
;;;890        int c;
;;;891    
;;;892        c = *(param_buf[ISP_CMD_CODE]);
000836  4c1b              LDR      r4,|L1.2212|
000838  4a1b              LDR      r2,|L1.2216|
00083a  6820              LDR      r0,[r4,#0]  ; param_buf
00083c  7801              LDRB     r1,[r0,#0]
;;;893        if(c != NUL);
;;;894        {
;;;895            switch(c)
;;;896            {
;;;897            /* Write to RAM command */
;;;898            case 'W':
;;;899                write_to_ram();
;;;900                break;
;;;901            /* Read command */
;;;902            case 'R':
;;;903                read();
;;;904                break;
;;;905            /* Go command */
;;;906            case 'G':
;;;907                go_cmd();
;;;908                break;
;;;909            /* Unlock command */
;;;910            case 'U':
;;;911                unlock();
;;;912                break;
;;;913            /* Read Part Identification number command */
;;;914            case 'J':
;;;915                param_table[IAP_CMD_CODE] = READ_PART_ID;
00083e  f1040014          ADD      r0,r4,#0x14
000842  3943              SUBS     r1,r1,#0x43           ;895
000844  f1000514          ADD      r5,r0,#0x14           ;895
000848  2915              CMP      r1,#0x15              ;895
00084a  d277              BCS      |L1.2364|
00084c  e8dff001          TBB      [pc,r1]               ;895
000850  808c838c          DCB      0x80,0x8c,0x83,0x8c
000854  118c8617          DCB      0x11,0x8c,0x86,0x17
000858  5c8c8936          DCB      0x5c,0x8c,0x89,0x36
00085c  8c7d8c0e          DCB      0x8c,0x7d,0x8c,0x0e
000860  8c8c148c          DCB      0x8c,0x8c,0x14,0x8c
000864  0b00              DCB      0x0b,0x00
000866  e8bd4070          POP      {r4-r6,lr}            ;899
00086a  e7fe              B        write_to_ram
00086c  e8bd4070          POP      {r4-r6,lr}            ;903
000870  e7fe              B        read
000872  e8bd4070          POP      {r4-r6,lr}            ;907
000876  e7fe              B        go_cmd
000878  e8bd4070          POP      {r4-r6,lr}            ;911
00087c  e7fe              B        unlock
00087e  2136              MOVS     r1,#0x36
000880  6001              STR      r1,[r0,#0]  ; param_table
000882  4908              LDR      r1,|L1.2212|
000884  3128              ADDS     r1,r1,#0x28
000886  f1a10014          SUB      r0,r1,#0x14
00088a  4790              BLX      r2
;;;916                iap_entry(param_table,result_table);
;;;917                sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
00088c  6861              LDR      r1,[r4,#4]  ; param_buf
00088e  220f              MOVS     r2,#0xf
000890  6828              LDR      r0,[r5,#0]  ; result_table
000892  f7fffffe          BL       i_to_a
000896  f7fffffe          BL       sendline_crlf
;;;918                PARAM_SIZE));
;;;919                sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
00089a  6861              LDR      r1,[r4,#4]  ; param_buf
;;;920                PARAM_SIZE));
;;;921            break;
00089c  6868              LDR      r0,[r5,#4]  ; result_table
00089e  e031              B        |L1.2308|
                  |L1.2208|
                          DCD      ||.data||
                  |L1.2212|
                          DCD      ||.bss||+0x94
                  |L1.2216|
                          DCD      0x1fff1ff1
                  |L1.2220|
                          DCD      0x12345678
                  |L1.2224|
                          DCD      0x87654321
                  |L1.2228|
                          DCD      0x11223344
                  |L1.2232|
                          DCD      0x2009c000
;;;922            /* read serial number command */
;;;923            case 'N':
;;;924                param_table[IAP_CMD_CODE] = READ_SERIAL_NUMBER;
0008bc  213a              MOVS     r1,#0x3a
0008be  6001              STR      r1,[r0,#0]  ; param_table
0008c0  495f              LDR      r1,|L1.2624|
0008c2  f1a10014          SUB      r0,r1,#0x14
0008c6  4790              BLX      r2
;;;925                iap_entry(param_table, result_table);
;;;926                sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
0008c8  6861              LDR      r1,[r4,#4]  ; param_buf
0008ca  220f              MOVS     r2,#0xf
0008cc  6828              LDR      r0,[r5,#0]  ; result_table
0008ce  f7fffffe          BL       i_to_a
0008d2  f7fffffe          BL       sendline_crlf
;;;927                PARAM_SIZE));
;;;928                sendline_crlf(i_to_a(result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
0008d6  6861              LDR      r1,[r4,#4]  ; param_buf
0008d8  220f              MOVS     r2,#0xf
0008da  6868              LDR      r0,[r5,#4]  ; result_table
0008dc  f7fffffe          BL       i_to_a
0008e0  f7fffffe          BL       sendline_crlf
;;;929                PARAM_SIZE));
;;;930                sendline_crlf(i_to_a(result_table[IAP_RESULT_1],param_buf[ISP_PARAM_1], \
0008e4  6861              LDR      r1,[r4,#4]  ; param_buf
0008e6  220f              MOVS     r2,#0xf
0008e8  68a8              LDR      r0,[r5,#8]  ; result_table
0008ea  f7fffffe          BL       i_to_a
0008ee  f7fffffe          BL       sendline_crlf
;;;931                PARAM_SIZE));
;;;932                sendline_crlf(i_to_a(result_table[IAP_RESULT_2],param_buf[ISP_PARAM_1], \
0008f2  6861              LDR      r1,[r4,#4]  ; param_buf
0008f4  220f              MOVS     r2,#0xf
0008f6  68e8              LDR      r0,[r5,#0xc]  ; result_table
0008f8  f7fffffe          BL       i_to_a
0008fc  f7fffffe          BL       sendline_crlf
;;;933                PARAM_SIZE));
;;;934                sendline_crlf(i_to_a(result_table[IAP_RESULT_3],param_buf[ISP_PARAM_1], \
000900  6861              LDR      r1,[r4,#4]  ; param_buf
000902  6928              LDR      r0,[r5,#0x10]  ; result_table
                  |L1.2308|
000904  220f              MOVS     r2,#0xf               ;919
000906  e01a              B        |L1.2366|
;;;935                PARAM_SIZE));
;;;936            break;
;;;937            /* Read Boot Code Version number command */
;;;938            case 'K':
;;;939                param_table[IAP_CMD_CODE] = READ_BOOT_VER;
000908  2137              MOVS     r1,#0x37
00090a  6001              STR      r1,[r0,#0]  ; param_table
00090c  494c              LDR      r1,|L1.2624|
00090e  f1a10014          SUB      r0,r1,#0x14
000912  4790              BLX      r2
;;;940                iap_entry(param_table,result_table);
;;;941                sendline_crlf(i_to_a(result_table[IAP_STAT_CODE],param_buf[ISP_PARAM_1], \
000914  6861              LDR      r1,[r4,#4]  ; param_buf
000916  220f              MOVS     r2,#0xf
000918  6828              LDR      r0,[r5,#0]  ; result_table
00091a  f7fffffe          BL       i_to_a
00091e  f7fffffe          BL       sendline_crlf
;;;942                PARAM_SIZE));
;;;943                sendline_crlf(i_to_a((char)result_table[IAP_RESULT_0],param_buf[ISP_PARAM_1], \
000922  6868              LDR      r0,[r5,#4]  ; result_table
000924  6861              LDR      r1,[r4,#4]  ; param_buf
000926  b2c0              UXTB     r0,r0
000928  220f              MOVS     r2,#0xf
00092a  f7fffffe          BL       i_to_a
00092e  f7fffffe          BL       sendline_crlf
;;;944                PARAM_SIZE));
;;;945                sendline_crlf(i_to_a((char)(result_table[IAP_RESULT_0]>>8),param_buf[ISP_PARAM_1], \
000932  6868              LDR      r0,[r5,#4]  ; result_table
000934  6861              LDR      r1,[r4,#4]  ; param_buf
000936  f3c02007          UBFX     r0,r0,#8,#8
;;;946                PARAM_SIZE));
;;;947                break;
00093a  e7e3              B        |L1.2308|
                  |L1.2364|
00093c  e014              B        |L1.2408|
                  |L1.2366|
;;;948            /* Prepare sector for write operation command */
;;;949            case 'P':
;;;950                prepare_sector();
;;;951                break;
;;;952            /* Copy RAM to FLASH command */
;;;953            case 'C':
;;;954                copy();
;;;955                break;
;;;956            /* Erase sector command */
;;;957            case 'E':
;;;958                erase();
;;;959                break;
;;;960            /* Blank check sector command */
;;;961            case 'I':
;;;962                blank_check();
;;;963                break;
;;;964            /* Compare Memory */
;;;965            case 'M':
;;;966                compare_mem();
;;;967                break;
;;;968            /* Invalid Command */
;;;969            default:
;;;970                sendline_crlf(i_to_a(INVALID_COMMAND,param_buf[ISP_PARAM_1], \
00093e  f7fffffe          BL       i_to_a
000942  e8bd4070          POP      {r4-r6,lr}
000946  f7ffbffe          B.W      sendline_crlf
00094a  e8bd4070          POP      {r4-r6,lr}            ;950
00094e  e7fe              B        prepare_sector
000950  e8bd4070          POP      {r4-r6,lr}            ;954
000954  e7fe              B        copy
000956  e8bd4070          POP      {r4-r6,lr}            ;958
00095a  e7fe              B        erase
00095c  e8bd4070          POP      {r4-r6,lr}            ;962
000960  e7fe              B        blank_check
000962  e8bd4070          POP      {r4-r6,lr}            ;966
000966  e7fe              B        compare_mem
                  |L1.2408|
000968  220f              MOVS     r2,#0xf
00096a  2001              MOVS     r0,#1
;;;971                PARAM_SIZE));
;;;972                break;
00096c  6861              LDR      r1,[r4,#4]  ; param_buf
00096e  e7e6              B        |L1.2366|
;;;973            } /* switch(c) */
;;;974        } /* if c != NUL */
;;;975    } /* exec_isp_cmd */
;;;976    
                          ENDP

                  isp_cmd_loop PROC
;;;977    /* only returns if timeout occurred */
;;;978    void isp_cmd_loop(void)
000970  e92d41fc          PUSH     {r2-r8,lr}
;;;979    {
;;;980        int cmd_len,no_of_param,crp_block_common_cmd,crp_block_crp2_crp3_cmd;
;;;981    	int result;
;;;982        
;;;983    	/* initialize to avoid compiler warning  */
;;;984        /* Lock Flash Write/Erase/Go Commands */
;;;985        lock = TRUE;
000974  f8df80cc          LDR      r8,|L1.2628|
000978  2101              MOVS     r1,#1
;;;986        
;;;987        /* intialize parameter buffer */
;;;988        param_buf[ISP_PARAM_0] = param0;
00097a  f8c81000          STR      r1,[r8,#0]  ; lock
00097e  4930              LDR      r1,|L1.2624|
;;;989        param_buf[ISP_PARAM_1] = param1;
;;;990        param_buf[ISP_PARAM_2] = param2;
;;;991        param_buf[ISP_PARAM_3] = param3;
;;;992        param_buf[ISP_PARAM_4] = param4;
;;;993    
;;;994        /* Initialize cp_after_reset variable to allow ISP session to program 
;;;995           code protection enabled user application */
;;;996    	crp_after_reset = crp;
;;;997    
;;;998    	crp_block_crp2_crp3_cmd = TRUE;
;;;999    
;;;1000   	while(1)
;;;1001       {
;;;1002   	    result = getline(cmd_buf,CMD_SIZE,&cmd_len);
;;;1003           if(result == 0)
;;;1004           {
;;;1005               /* To safegaurd against insufficient parameters fill parameter buffers with
;;;1006                  Non numeric ascii charcaters */
;;;1007               for(no_of_param=0;no_of_param<NO_OF_ISP_PARAMS;no_of_param++)
;;;1008               {
;;;1009                   *(param_buf[no_of_param]) = 'z';
;;;1010               }
;;;1011               no_of_param = tokenize(&cmd_buf[0],cmd_len,&param_buf[0],NO_OF_ISP_PARAMS,PARAM_SIZE);  
;;;1012               if(no_of_param != 0)
;;;1013               {
;;;1014                  /* Common ISP commands to be blocked for code read protection Level 1, 2 or 3 */
;;;1015                  if( ( (*(param_buf[ISP_CMD_CODE]) == 'R') ||              \
;;;1016                        (*(param_buf[ISP_CMD_CODE]) == 'G') ||              \
;;;1017                        (*(param_buf[ISP_CMD_CODE]) == 'M') ) )
;;;1018                  {
;;;1019                     crp_block_common_cmd = TRUE;
;;;1020                  }
;;;1021                  else
;;;1022                  {
;;;1023                     crp_block_common_cmd = FALSE;
;;;1024                     /* ISP commands to be blocked for code read protection Level 2 and 3 */
;;;1025                     if( ( (*(param_buf[ISP_CMD_CODE]) == 'W') ||              \
;;;1026                           (*(param_buf[ISP_CMD_CODE]) == 'C') ) )
;;;1027                     {
;;;1028                        crp_block_crp2_crp3_cmd = TRUE;
;;;1029                     }
;;;1030                     else
;;;1031                     {
;;;1032                        crp_block_crp2_crp3_cmd = FALSE;
;;;1033                     }
;;;1034                  }
;;;1035   
;;;1036                  if( ( (crp_after_reset == CRP1) ||            \
;;;1037                        (crp_after_reset == CRP2) ||     \
000980  4e32              LDR      r6,|L1.2636|
000982  3976              SUBS     r1,r1,#0x76           ;988
000984  f101054e          ADD      r5,r1,#0x4e           ;988
000988  6029              STR      r1,[r5,#0]            ;989  ; param_buf
00098a  310f              ADDS     r1,r1,#0xf            ;989
00098c  6069              STR      r1,[r5,#4]            ;990  ; param_buf
00098e  310f              ADDS     r1,r1,#0xf            ;990
000990  60a9              STR      r1,[r5,#8]            ;991  ; param_buf
000992  310f              ADDS     r1,r1,#0xf            ;991
000994  60e9              STR      r1,[r5,#0xc]          ;992  ; param_buf
000996  310f              ADDS     r1,r1,#0xf            ;992
000998  6129              STR      r1,[r5,#0x10]         ;996  ; param_buf
00099a  492b              LDR      r1,|L1.2632|
00099c  2401              MOVS     r4,#1                 ;998
00099e  6809              LDR      r1,[r1,#0]            ;996  ; crp
;;;1038                        (crp_after_reset == CRP3) )      \
0009a0  ea4f4736          ROR      r7,r6,#16
0009a4  f8c81004          STR      r1,[r8,#4]  ; crp_after_reset
                  |L1.2472|
0009a8  4825              LDR      r0,|L1.2624|
0009aa  aa01              ADD      r2,sp,#4              ;1002
0009ac  2146              MOVS     r1,#0x46              ;1002
0009ae  38bc              SUBS     r0,r0,#0xbc           ;1002
0009b0  f7fffffe          BL       getline
0009b4  2800              CMP      r0,#0                 ;1003
0009b6  d141              BNE      |L1.2620|
0009b8  f05f017a          MOVS.W   r1,#0x7a              ;1009
                  |L1.2492|
0009bc  f8552020          LDR      r2,[r5,r0,LSL #2]     ;1009
0009c0  1c40              ADDS     r0,r0,#1              ;1007
0009c2  7011              STRB     r1,[r2,#0]            ;1009
0009c4  2805              CMP      r0,#5                 ;1007
0009c6  dbf9              BLT      |L1.2492|
0009c8  4a1d              LDR      r2,|L1.2624|
0009ca  230f              MOVS     r3,#0xf               ;1011
0009cc  9300              STR      r3,[sp,#0]            ;1011
0009ce  3a28              SUBS     r2,r2,#0x28           ;1011
0009d0  2305              MOVS     r3,#5                 ;1011
0009d2  f1a20094          SUB      r0,r2,#0x94           ;1011
0009d6  9901              LDR      r1,[sp,#4]            ;1011
0009d8  f7fffffe          BL       tokenize
0009dc  2800              CMP      r0,#0                 ;1012
0009de  d0e3              BEQ      |L1.2472|
0009e0  6829              LDR      r1,[r5,#0]            ;1015  ; param_buf
0009e2  7809              LDRB     r1,[r1,#0]            ;1015
0009e4  2952              CMP      r1,#0x52              ;1015
0009e6  d003              BEQ      |L1.2544|
0009e8  2947              CMP      r1,#0x47              ;1016
0009ea  d001              BEQ      |L1.2544|
0009ec  294d              CMP      r1,#0x4d              ;1017
0009ee  d101              BNE      |L1.2548|
                  |L1.2544|
0009f0  2201              MOVS     r2,#1                 ;1019
0009f2  e007              B        |L1.2564|
                  |L1.2548|
0009f4  2200              MOVS     r2,#0                 ;1023
0009f6  2957              CMP      r1,#0x57              ;1025
0009f8  d001              BEQ      |L1.2558|
0009fa  2943              CMP      r1,#0x43              ;1026
0009fc  d101              BNE      |L1.2562|
                  |L1.2558|
0009fe  2401              MOVS     r4,#1                 ;1028
000a00  e000              B        |L1.2564|
                  |L1.2562|
000a02  2400              MOVS     r4,#0                 ;1032
                  |L1.2564|
000a04  4b12              LDR      r3,|L1.2640|
000a06  f8d81004          LDR      r1,[r8,#4]            ;1036  ; crp_after_reset
000a0a  4299              CMP      r1,r3                 ;1036
000a0c  d003              BEQ      |L1.2582|
000a0e  42b1              CMP      r1,r6                 ;1037
000a10  d001              BEQ      |L1.2582|
000a12  42b9              CMP      r1,r7
000a14  d109              BNE      |L1.2602|
                  |L1.2582|
;;;1039                                           &&                                 \
;;;1040                       ( crp_block_common_cmd == TRUE )
000a16  2a01              CMP      r2,#1
000a18  d107              BNE      |L1.2602|
                  |L1.2586|
;;;1041                     )
;;;1042                   {
;;;1043                       /* Code read protection Level 1, 2 or 3 enabled. Block Read,
;;;1044                          Go and Compare ISP commands */
;;;1045                       sendline_crlf(i_to_a(CODE_READ_PROTECTION_ENABLED, \
000a1a  220f              MOVS     r2,#0xf
000a1c  2013              MOVS     r0,#0x13
000a1e  6869              LDR      r1,[r5,#4]  ; param_buf
000a20  f7fffffe          BL       i_to_a
000a24  f7fffffe          BL       sendline_crlf
000a28  e7be              B        |L1.2472|
                  |L1.2602|
;;;1046                       param_buf[ISP_PARAM_1],PARAM_SIZE));
;;;1047                   }  
;;;1048                   else
;;;1049                   {
;;;1050                      if( ( (crp_after_reset == CRP2) ||            \
000a2a  42b1              CMP      r1,r6
000a2c  d001              BEQ      |L1.2610|
;;;1051                            (crp_after_reset == CRP3) )  
000a2e  42b9              CMP      r1,r7
000a30  d101              BNE      |L1.2614|
                  |L1.2610|
;;;1052                                            &&                                   \
;;;1053                           ( crp_block_crp2_crp3_cmd == TRUE ) )
000a32  2c01              CMP      r4,#1
000a34  d0f1              BEQ      |L1.2586|
                  |L1.2614|
;;;1054                      {
;;;1055                       /* Code read protection Level 2 or 3 is enabled. Block Write
;;;1056                          and Copy ISP commands */
;;;1057                          sendline_crlf(i_to_a(CODE_READ_PROTECTION_ENABLED, \
;;;1058                          param_buf[ISP_PARAM_1],PARAM_SIZE));
;;;1059                      }
;;;1060                      else
;;;1061                      {
;;;1062                          exec_isp_cmd(no_of_param);
000a36  f7fffffe          BL       exec_isp_cmd
000a3a  e7b5              B        |L1.2472|
                  |L1.2620|
;;;1063                      }
;;;1064                   }
;;;1065               } /* if(no_of_param != 0) */
;;;1066           } /* if(serial_getline(cmd_buf,CMD_SIZE,&cmd_len) == 0) */
;;;1067   		else
;;;1068   		{
;;;1069   		  /* timeout */
;;;1070   		  return;
;;;1071   		}
;;;1072   	} /* While(1) loop */
;;;1073   } /* isp_cmd_loop */
000a3c  e8bd81fc          POP      {r2-r8,pc}
                          ENDP

                  |L1.2624|
                          DCD      ||.bss||+0xbc
                  |L1.2628|
                          DCD      ||.data||
                  |L1.2632|
                          DCD      ||crp||
                  |L1.2636|
                          DCD      0x87654321
                  |L1.2640|
                          DCD      0x12345678

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  cmd_buf
                          %        70
                  param0
                          %        15
                  param1
                          %        15
                  param2
                          %        15
                  param3
                          %        15
                  param4
                          %        18
                  param_buf
                          %        20
                  param_table
                          %        20
                  result_table
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  unlock_code
                          DCD      0x00005a5a

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.6||, ||.constdata||
                  ||ok||
000000  4f4b00            DCB      0x4f,0x4b,0x00
                  resend
000003  52                DCB      0x52
000004  4553454e          DCB      0x45,0x53,0x45,0x4e
000008  4400              DCB      0x44,0x00
                  sync_str
00000a  5379              DCB      0x53,0x79
00000c  6e636872          DCB      0x6e,0x63,0x68,0x72
000010  6f6e697a          DCB      0x6f,0x6e,0x69,0x7a
000014  656400            DCB      0x65,0x64,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  lock
                          DCD      0x00000000
                  crp_after_reset
                          DCD      0x00000000
